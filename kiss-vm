#!/bin/bash
# author: yin-jianhong@163.com
# test pass on RHEL-7/CentOS-7, RHEL-8/CentOS-8 and Fedora-29/30/31
#
# inspired by https://www.brianlinkletter.com/2019/02/build-a-network-emulator-using-libvirt/
# `and inspired by Red Hat traning Virtual Lab

LANG=C
PATH=~/bin:$PATH 

P=$0
[[ $0 = /* ]] && P=${0##*/}
Distro=
Location=
Imageurl=
VM_OS_VARIANT=
OVERWRITE=no
KSPath=
ksauto=
MacvtapMode=bridge
VMName=
InstallType=import

ImagePath=~/myimages
VMSHOME=~/VMs
perConfDir=~/.config/kiss-vm
vmprefix=$(whoami)
[[ -n "$SUDO_USER" ]] && {
	eval ImagePath=~$SUDO_USER/myimages
	eval VMSHOME=~$SUDO_USER/VMs
	eval perConfDir=~$SUDO_USER/.config/kiss-vm
	vmprefix=${SUDO_USER}
}

DownloadImagePath=$ImagePath/download
RuntimeTmp=/tmp/vm-$$
INTERACT=yes
Intranet=yes
VIRT_READY=unkown
_MSIZE=1536
DSIZE=27
baudrate=115200
QEMU_OPTS=()
QEMU_ENV=()
_downhostname="download.devel.fedorahat.com"
downhostname=${_downhostname/fedora/red}
baseUrl=http://$downhostname/qa/rhts/lookaside/kiss-vm-ns
bkrClientImprovedUrl=http://$downhostname/qa/rhts/lookaside/bkr-client-improved
VCPUS=4
defaultPasswd=redhat

Cleanup() {
	cd ~
	#echo "{DEBUG} Removing $RuntimeTmp"
	rm -rf $RuntimeTmp
	[[ -n "$VMpath" ]] && { rmdir "$VMpath" && rmdir "${VMpath%/*}"; } 2>/dev/null
	exit
}
trap Cleanup EXIT #SIGINT SIGQUIT SIGTERM
#-------------------------------------------------------------------------------

vmname_gen() {
	local distro=$1
	local cname=$2
	local name=${Distro//./}
	name=${name,,}

	if [[ -n "$cname" ]]; then
		name=${cname}
	else
		[[ -n "$vmprefix" ]] && name=${vmprefix}-${name}
	fi
	echo -n $name
}

_vmdelete() {
	local _vmname=$1
	[[ -z "$_vmname" ]] && {
		return 1
	}

	egrep -q "^$_vmname$" <(virsh list --name --all) || {
		echo -e "{VM:WARN} VM '$_vmname' does not exist"
		return 1
	}

	homedir=$(getent passwd "$vmprefix" | cut -d: -f6)
	if [[ -n "${vmprefix}" ]]; then
		blk=$(virsh domblklist "$_vmname" | sed 1,2d)
		if test -n "$blk"; then
			! grep -q "$homedir/VM[sS]/" <<<"$blk" && {
				echo -e "{VM:WARN} VM '$_vmname' was not created by current user; try:"
				cat <<-EOF
				  virsh destroy $_vmname
				  virsh undefine $_vmname --remove-all-storage --nvram
				EOF
				return 1
			}
		#pxe vms
		elif [[ ! -d $homedir/VMs/PXE/$_vmname ]]; then
			echo -e "{VM:WARN} VM '$_vmname' was not created by current user; try:"
			cat <<-EOF
			  virsh destroy $_vmname
			  virsh undefine $_vmname --remove-all-storage --nvram
			EOF
			return 1
		fi
	else
		:
	fi

	local _vmdir=
	local _image=$(virsh dumpxml --domain $_vmname | sed -n "/source file=.*qcow/{s|^.*='||; s|'/>$||; p; q}")
	if test -n "$_image"; then
		_vmdir=$(dirname $_image)
	else
		_vmdir=$homedir/VMs/PXE/$_vmname
	fi

	echo -e "\n{VM:INFO} => dist removing VM $_vmname .."
	virsh destroy $_vmname 2>/dev/null; sleep 0.5
	_std=$(virsh undefine $_vmname --remove-all-storage --nvram 2>&1)
	if grep -q "error: Refusing to undefine while domain managed save image exists" <(echo "$_std"); then
		virsh managedsave-remove $_vmname 2>/dev/null
		virsh undefine $_vmname --remove-all-storage --nvram
	else
		echo "$_std"
	fi

	if [[ "$_vmdir" = $VMSHOME/?*/$_vmname ]]; then
		echo -e "- {VM:INFO} removing VM folder $_vmdir ..."
		rm -f $_vmdir/{url,nohup.log,ext4.qcow2,xfs.qcow2,vm.xml,qemu.argv,.kiss-vm}
		rm -f $_vmdir/*.cfg $_vmdir/*.ks
		rm -f $_vmdir/*.qcow2.xz $_vmdir/*.img $_vmdir/*.image
		rm -f $_vmdir/nvdimm-*.dev
		rmdir $_vmdir 2>/dev/null
		rmdir ${_vmdir%/*} 2>/dev/null
	fi
	return 0
}

vmdialogchecklist() {
	local cmdinfo=$1
	local resfile=$2
	local all=$3
	local vmlist=$(virsh list --name ${all:+--all})
	[[ -n "$vmprefix" ]] && vmlist=$(grep "^$vmprefix" <<<"$vmlist"; grep -v "^$vmprefix" <<<"$vmlist";)
	local vmList=$(echo "$vmlist" | sed -e /^$/d -e 's/.*/"&" "" 1/')
	[[ -z "${vmList}" ]] && {
		echo -e "{VM:WARN} there is not any VM in your host .." >&2
		return 1;
	}
	dialog --backtitle "$cmdinfo" --separate-output --checklist "${cmdinfo}: please select vms you want " 30 120 28 $vmList 2>$resfile; rc=$?
	printf '\33[H\33[2J'
	return $rc
}
vmdialogradiolist() {
	local cmdinfo=$1
	local resfile=$2
	local all=$3
	local vmlist=$(virsh list --name ${all:+--all})
	[[ -n "$vmprefix" ]] && vmlist=$(grep "^$vmprefix" <<<"$vmlist"; grep -v "^$vmprefix" <<<"$vmlist";)
	local vmList=$(echo "$vmlist" | sed -e /^$/d -e 's/.*/"&" "" 1/')
	[[ -z "${vmList}" ]] && {
		echo -e "{VM:WARN} there is not any VM in your host .." >&2
		return 1;
	}
	dialog --backtitle "$cmdinfo" --radiolist "${cmdinfo}: please select vm you want " 30 60 28 $vmList 2>$resfile; rc=$?
	printf '\33[H\33[2J'
	return $rc
}

vmdelete() {
	[[ $# = 0 ]] && {
		resf=$RuntimeTmp/vmlist
		vmdialogchecklist vm-delete $resf all && rmList=$(< $resf)
		[[ -z "$rmList" ]] && { return; }
		eval set $rmList
	}
	for vm; do _vmdelete $vm; done
}

vmifaddr() {
	[[ "$1" = /x ]] && {
		shift
		local GETENT=yes
	}

	local _vmname=$1
	[[ -z "$_vmname" ]] && {
		resf=$RuntimeTmp/vmlist
		vmdialogradiolist vm-ifaddr $resf && _vmname=$(sed 's/"//g' $resf)
		[[ -z "$_vmname" ]] && { return; }
	}

	local addrs=
	if [[ "$GETENT" = yes ]]; then
		addrs=$(getent hosts "$_vmname"|awk '{print $1}'|tac)
	else
		addrs=$(virsh --quiet domifaddr "$_vmname" | awk '{print gensub("/.*","",1,$4)}')
	fi
	[[ -n "$addrs" ]] && echo "$addrs"
}

vncgetsc() {
	local vncport=$1
	local _vmname=$2

	! command -v vncdo >/dev/null && {
		echo "{VM:WARN} command vncdo is needed by 'vncgetsc/vncgetscreen' function!" >&2
		return 1
	}
	local fname=$_vmname-screen-$(date +%F_%T_%N).png
	vncdo -s $vncport capture $RuntimeTmp/_screen.png
	mv $RuntimeTmp/_screen.png ./$fname
	ls -lh $fname
}

image_binarize() {
	local srcf=${1}
	local dstf=${2:-new-${srcf}}

	if command -v anytopnm >/dev/null; then
		anytopnm $srcf | ppmtopgm | pgmtopbm -threshold | pnmtopng > $dstf
	else
		local ConvertCmd="gm convert"
		! command -v gm >/dev/null && {
			if ! command -v convert >/dev/null; then
				echo "{VM:WARN} command gm or convert are needed by 'vncget' function!" >&2
				return 1
			else
				ConvertCmd=convert
			fi
		}
		$ConvertCmd $srcf -threshold 30% $dstf
	fi

	return 0
}

vncget() {
	local vncport=$1

	! command -v vncdo >/dev/null && {
		echo "{VM:WARN} command vncdo is needed by 'vncget' function!" >&2
		return 1
	}
	! command -v gocr >/dev/null && {
		echo "{VM:WARN} command gocr is needed by 'vncget' function!" >&2
		return 1
	}
	vncdo -s $vncport capture $RuntimeTmp/_screen.png
	image_binarize $RuntimeTmp/_screen.png $RuntimeTmp/_screen2.png || return 1
	gocr -i $RuntimeTmp/_screen2.png 2>/dev/null | GREP_COLORS='ms=01;30;47' grep --color .
}

vncput() {
	local vncport=$1
	shift

	command -v vncdo || {
		echo "{VM:WARN} vncdo is needed by 'vncput' function!" >&2
		return 1
	}

	local msgArray=()
	for msg; do
		if [[ -n "$msg" ]]; then
			if [[ "$msg" = key:* ]]; then
				msgArray+=("$msg")
			else
				regex='[~@#$%^&*()_+|}{":?><!]'
				_msg="${msg#type:}"
				if [[ "$_msg" =~ $regex ]]; then
					while IFS= read -r line; do
						if [[ "$line" = key:shift-? ]]; then
							: #line=key:shift-$(tr ')~!@#$%^&*(+}{|:><?"'   '0`123456789=][\\;.,/'"'" <<<"${line: -1}")
						else
							line="type:$line"
						fi
						msgArray+=("$line")
					done < <(sed -r -e 's;[~!@#$%^&*()_+|}{":?><]+;&\n;g' -e 's;[~!@#$%^&*()_+|}{":?><];\nkey:shift-&;g' <<<"$_msg")
				else
					msgArray+=("$msg")
				fi
			fi
			msgArray+=("")
		else
			msgArray+=("$msg")
		fi

	done
	for msg in "${msgArray[@]}"; do
		if [[ -n "$msg" ]]; then
			if [[ "$msg" = key:* ]]; then
				vncdo --force-caps -s $vncport key "${msg#key:}"
			else
				vncdo --force-caps -s $vncport type "${msg#type:}"
			fi
		else
			sleep 1
		fi
	done
}

vmvncproc() {
	local _vmname=$1
	[[ -z "$_vmname" ]] && {
		resf=$RuntimeTmp/vmlist
		vmdialogradiolist vm-vncproc $resf all && _vmname=$(sed 's/"//g' $resf)
		[[ -z "$_vmname" ]] && { return; }
	}

	local port=$(virsh dumpxml "$_vmname" | sed -rn "/.* type=.vnc. port=.([0-9]+).*/{s//\1/;p}")
	if [[ -n "${port}" ]]; then
		if [[ -z "${VNCPUTS}" && -z "${VNCGET}" && -z "${VNCGETSC}" ]]; then
			for _host in $(hostname -A|xargs -n 1|sort -u); do
				ping -c 2 $_host &>/dev/null || continue
				echo $_host:$port
			done
			return
		fi

		if [[ -n "${VNCPUTS}" ]]; then
			vncput localhost::$port "${VNCPUTS[@]}"
			echo "[vncput@$_vmname]> ${VNCPUTS[*]}"
		fi
		if [[ -n "${VNCGETSC}" ]]; then
			echo "[vncgetsc@$_vmname]:"
			vncgetsc localhost::$port $_vmname
		fi
		if [[ -n "${VNCGET}" ]]; then
			echo "[vncget@$_vmname]:"
			vncget localhost::$port $_vmname
		fi
	fi
}

vmxml() {
	local _vmname=$1
	[[ -z "$_vmname" ]] && {
		resf=$RuntimeTmp/vmlist
		vmdialogradiolist vm-dumpxml $resf all && _vmname=$(sed 's/"//g' $resf)
		[[ -z "$_vmname" ]] && { return; }
	}

	virsh dumpxml "$_vmname"
}

vmedit() {
	local _vmname=$1
	[[ -z "$_vmname" ]] && {
		resf=$RuntimeTmp/vmlist
		vmdialogradiolist vm-edit $resf all && _vmname=$(sed 's/"//g' $resf)
		[[ -z "$_vmname" ]] && { return; }
	}

	virsh edit "$_vmname"
}

port_available() {
	nc $(grep -q -- '-z\>' < <(nc -h 2>&1) && echo -z) $1 $2 </dev/null &>/dev/null
}

vmreboot() {
	local _vmname=$1
	[[ -z "$_vmname" ]] && {
		resf=$RuntimeTmp/vmlist
		vmdialogradiolist vm-reboot $resf all && _vmname=$(sed 's/"//g' $resf)
		[[ -z "$_vmname" ]] && { return; }
	}

	virsh destroy "$_vmname" 2>/dev/null
	virsh start "$_vmname"
	[[ "$WAIT" = yes ]] && {
		echo -e "{VM:INFO} waiting restart finish ..."
		until port_available ${_vmname} 22; do sleep 1; done
	}
}

vmstop() {
	local _vmname=$1
	[[ -z "$_vmname" ]] && {
		resf=$RuntimeTmp/vmlist
		vmdialogchecklist vm-shutdown $resf all && vmList=$(< $resf)
		[[ -z "$vmList" ]] && { return; }
		eval set $vmList
	}

	for vm; do virsh destroy "$vm"; done
}

vmstart() {
	local _vmname=$1
	[[ -z "$_vmname" ]] && {
		resf=$RuntimeTmp/vmlist
		vmdialogchecklist vm-start $resf all && vmList=$(< $resf)
		[[ -z "$vmList" ]] && { return; }
		eval set $vmList
	}

	for vm; do virsh start "$vm"; done
}

vmclone() {
	[[ "$1" = /a ]] && {
		shift
		local APPEND=yes
	}

	is_invalid_vmname() {
		local nvmname=$1
		egrep --color=always "[][~\!@#$^&()=,\":;{}|<>'\` ]" <<<"$nvmname"
	}

	local dstname=$1
	local srcname=$2
	[[ -z "$srcname" ]] && {
		resf=$RuntimeTmp/vmlist
		vmdialogradiolist vm-clone $resf all && srcname=$(sed 's/"//g' $resf)
		[[ -z "$srcname" ]] && {
			return;
		}
	}
	if [[ -z "$dstname" ]]; then
		dstname=${srcname}-clone-$$
	else
		#verify invalid charactors
		[[ "$APPEND" = yes ]] && dstname=${srcname}-${dstname}
	fi
	is_invalid_vmname "$dstname" && return 1

	#get src vm path
	read image < <(virsh dumpxml --domain ${srcname} | sed -n "/source file=/{s|^.*='||; s|'/>$||; p}")
	local srcpath=${image%/*}
	[[ ! -f ${srcpath}/.kiss-vm || ${srcpath##*/} != ${srcname} ]] && {
		echo -e "{VM:WARN} seems $srcname was not created by kiss-vm, can not use vm-clone; please use virt-clone instead ..."
		return 1
	}

	virsh suspend "$srcname"

	# do clone
	local dstpath=${srcpath%/*}/$dstname
	mkdir -p $dstpath
	virt-clone --original ${srcname} --name ${dstname} --file $dstpath/vm.qcow2
	#fix me: Permission denied, why new image owner is root?
	LIBGUESTFS_BACKEND=direct virt-sysprep -d ${dstname} --hostname $dstname --enable user-account,ssh-hostkeys,net-hostname,net-hwaddr,machine-id --remove-user-accounts bar --run 'ls'

	virsh resume "$srcname"
}

vmcopyto() {
	[[ "$#" -lt 3 ]] && {
		echo "Usage: vm cpto vmname <src files/dirs ...> <dst dir in vm>"
		return 1
	}
	local _vmname=$1
	shift 1
	local dstdir=${@: -1}
	local srcarray=("${@:1: $#-1}")

	port_available $_vmname 22 || {
		echo -e "{VM:WARN} port $_vmname:22 is not available"
		return 1
	}

	local sshexec=no
	local sshOpts="-o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -o GSSAPIAuthentication=no"
	ssh -n -o Batchmode=yes $sshOpts root@$_vmname &>$RuntimeTmp/sshtest
	[[ $? = 0 ]] && sshexec=yes
	if [[ $sshexec = yes ]]; then
		scp $sshOpts -r "${srcarray[@]}" root@${_vmname}:$dstdir/.
		rc=$?
		[[ $rc = 0 ]] && {
			ssh $sshOpts root@${_vmname} ls -l $dstdir
		}
	else
		if grep -q -w password $RuntimeTmp/sshtest; then
			expect <(cat <<-EOF
			set timeout 120
			spawn scp $sshOpts -r "${srcarray[@]}" root@${_vmname}:$dstdir/.
			expect {
				"password:" { send "$defaultPasswd\r"; exp_continue }
				"Password for" { send "$defaultPasswd\r"; exp_continue }
				eof
			}
			foreach {pid spawnid os_error_flag value} [wait] break
			exit \$value
			EOF
			)
			rc=$?
		else
			echo -e "{VM:WARN} ssh $_vmname is not available ..."
			rc=1
		fi
	fi
	return $rc
}

vmcopyfrom() {
	[[ "$#" -lt 3 ]] && {
		echo "Usage: vm cpfrom vmname <file/dir> <dst dir>"
		return 1
	}
	local _vmname=$1
	shift 1
	local src=${1%/}
	local dstdir=$2

	port_available $_vmname 22 || {
		echo -e "{VM:WARN} port $_vmname:22 is not available"
		return 1
	}

	local sshexec=no
	local sshOpts="-o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -o GSSAPIAuthentication=no"
	ssh -n -o Batchmode=yes $sshOpts root@$_vmname &>$RuntimeTmp/sshtest
	[[ $? = 0 ]] && sshexec=yes
	if [[ $sshexec = yes ]]; then
		scp $sshOpts -r root@${_vmname}:$src $dstdir/.
		rc=$?
		[[ $rc = 0 ]] && {
			ls -l -d $dstdir/${src##*/}
		}
	else
		if grep -q -w password $RuntimeTmp/sshtest; then
			expect <(cat <<-EOF
			set timeout 120
			spawn scp -r root@${_vmname}:$src $dstdir/.
			expect {
				"password:" { send "$defaultPasswd\r"; exp_continue }
				"Password for" { send "$defaultPasswd\r"; exp_continue }
				eof
			}
			foreach {pid spawnid os_error_flag value} [wait] break
			exit \$value
			EOF
			)
			rc=$?
		else
			echo -e "{VM:WARN} ssh $_vmname is not available ..."
			rc=1
		fi
	fi
	return $rc
}

vmconsole() {
	local _vmname=$1
	shift
	[[ -z "$_vmname" ]] && {
		resf=$RuntimeTmp/vmlist
		vmdialogradiolist vm-console $resf && _vmname=$(sed 's/"//g' $resf)
		[[ -z "$_vmname" ]] && { return; }
	}
	virsh console "$_vmname"
	return $?
}

vmlogin() {
	local _vmname=$1
	shift
	[[ -z "$_vmname" ]] && {
		resf=$RuntimeTmp/vmlist
		vmdialogradiolist vm-login $resf && _vmname=$(sed 's/"//g' $resf)
		[[ -z "$_vmname" ]] && { return; }
	}

	[[ "${EXEC}" = yes ]] && {
		[[ $# = 0 ]] && set "exit 0";
		[[ "$VERBOSE" = yes ]] &&
			echo "[root@$_vmname]> $*" | GREP_COLORS='ms=01;36' grep --color . >&2
	}

	#sometimes there's bug in libnss. get more than one addr but some one
	#of them does not exist. detect and ignore it/them
	addrs=$(vmifaddr "$_vmname")
	[[ -z "$addrs" ]] && {
		echo -e "{VM:WARN} can not get ip info of $_vmname, try login with console ..."
		virsh console "$_vmname"
		return $?
	}

	local sshOpts="-o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -o GSSAPIAuthentication=no"
	echo "$*" >$RuntimeTmp/sshcmd
	for addr in $addrs; do
		[[ "$DEBUG" = yes ]] &&
			echo "[vmlogin:debug] detect port ${addr}:22 ..." | GREP_COLORS='ms=01;36' grep --color . >&2

		port_available $addr 22 || {
			echo -e "{VM:WARN} port $addr:22 is not available"
			continue
		}

		[[ "$DEBUG" = yes ]] &&
			echo "[vmlogin:debug] port ${addr}:22 available ..." | GREP_COLORS='ms=01;36' grep --color . >&2

		sshexec=no
		ssh -n -o Batchmode=yes $sshOpts root@$addr &>$RuntimeTmp/sshtest
		[[ $? = 0 ]] && sshexec=yes
		if [[ $sshexec = yes ]]; then
			ssh $sshOpts root@$addr "$*"
			rc=$?
		else
			if grep -q -w password $RuntimeTmp/sshtest; then
				expect <(cat <<-EOF
				set timeout 120
				set sshcmd [exec cat $RuntimeTmp/sshcmd]
				log_user 0
				spawn ssh $sshOpts root@$addr \$sshcmd
				log_user 1
				if {\$argc == 0} {
					expect {
					"password:" { send "$defaultPasswd\r"; exp_continue }
					"Password for" { send "$defaultPasswd\r"; exp_continue }
					"*# " { send "\r"; interact }
					}
				} else {
					expect {
					"password:" { send "$defaultPasswd\r"; exp_continue }
					"Password for" { send "$defaultPasswd\r"; exp_continue }
					eof
					}
				}
				foreach {pid spawnid os_error_flag value} [wait] break
				exit \$value
				EOF
				) "$@"
				rc=$?
			else
				echo -e "{VM:WARN} ssh root@$addr is not available, try login with console ..."
				virsh console "$_vmname"
				rc=$?
			fi
		fi

		faillog() { echo -e "\033[41m{TEST:FAIL} $*\033[0m"; }
		[[ -n "$expectedrc" ]] && {
			[[ " ${expectedrc[@]} " != *" $rc "* ]] && {
				faillog "return code: expect $expectedRC, but got $rc"
			}
		}

		return $rc
	done
}

vmexec() { EXEC=yes vmlogin "$@"; }
vmlist() { virsh list --all; }
netls() { virsh net-list; }
netcreate() {
	local netname=
	local brname=
	local subnet=
	local forward=nat

	[[ $# = 0 ]] && { virsh net-list; return; }
	Usage() {
		cat <<-U
		Example:
		  vm netcreat netname=net10 brname=virbr10 subnet=10  #means 192.168.10.0
		  vm netcreat netname=net10 brname=virbr10 subnet=172.25.252.0
		  vm netcreat netname=net10 brname=virbr10 subnet=172.25.252.0 forward=no
		  vm netcreat netname=net10 brname=virbr10 subnet=172.25.252.0 forward=nat [tftproot=/path] [bootpfile=]
		U
	}
	for opt; do [[ "$opt" =~ ^(netname|brname|subnet|forward|tftproot|bootpfile)=.* ]] || continue; eval "$opt"; done
	[[ -z "$netname" || -z "$brname" ]] && { Usage >&2; return 1; }

	#https://libvirt.org/formatnetwork.html
	[[ -n "$forward" && "$forward" != no ]] && {
		forwardNode="<forward mode=\"$forward\"/>"
		[[ "$forward" = nat ]] && forwardNode="<forward mode=\"$forward\" >
		    <nat>
		      <port start='1024' end='65535'/>
		    </nat>
		  </forward>"
	}
	[[ -n "$tftproot" ]] && tftpNode="<tftp root='$tftproot'/>"
	[[ -n "$bootpfile" ]] && bootpNode="<bootp file='$bootpfile'/>"
	if [[ -n "$subnet" ]]; then
		netmask=255.255.255.0
		rx='([1-9]?[0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])'
		if [[ "$subnet" =~ ^${rx}$ ]]; then
			subnet=192.168.${subnet}
		elif [[ "$subnet" =~ ^$rx\.$rx\.$rx$ ]]; then
			subnet=${subnet}
		elif [[ "$subnet" =~ ^$rx\.$rx\.$rx\.$rx$ ]]; then
			subnet=${subnet%.*}
		else
			echo "{VM:netcreate} invalid subnet addr: $subnet" >&2
			Usage >&2
			return 1
		fi

		gatewayaddr="${subnet}.1"
		range_start="${subnet}.128"
		range_end="${subnet}.254"

		ipNode="<ip address=\"${subnet}.1\" netmask=\"$netmask\" >
		    $tftpNode
		    <dhcp>
		      <range start=\"${range_start}\" end=\"${range_end}\"/>
		      $bootpNode
		    </dhcp>
		  </ip>"
	fi

	virsh net-info -- "$netname" &>/dev/null && {
		echo "{VM:WARN} Virt network $netname has been there."
		return
	}

	virsh net-define --file <(
		cat <<-NET
		<network>
		  <name>$netname</name>
		  <bridge name="$brname" />
		  $forwardNode
		  $ipNode
		</network>
		NET
	)
	virsh net-start $netname
	virsh net-autostart $netname
}
netinfo() {
	for net; do
		virsh net-info -- $net || continue
		virsh net-dumpxml -- $net
	done
}
netstart() {
	for net; do
		virsh net-start -- $net
	done
}
netdelete() {
	echo -e "\n{VM:INFO} => delete virtual net: $@ .."
	for net; do
		virsh net-destroy -- $net
		virsh net-undefine -- $net
	done
}

vercmp() {
	usage() {
		echo "usage: vercmp  <ver1> < =  | '>' | '<' | '>=' | '<=' >  <ver2>" >&2
		echo "       vercmp  <ver1> < eq | gt  | lt  |  ge  |  le  >  <ver2>" >&2
		echo "       vercmp  <ver1> < match >  <'pattern'>" >&2
	}

	[ $# != 3 ] && {
		usage
		return 1
	}
	vl=$1
	cmpType=$2
	vr=$3
	res=1

	[ "$vl" = "$vr" ] && eq=1
	vmax=$(echo -e "$vl\n$vr" | sort -V | tail -n 1)

	case "$cmpType" in
	=|eq) [ "$eq" = 1 ] && res=0;;
	\>|gt) [ "$eq" != 1 -a "$vl" = "$vmax" ] && res=0;;
	\<|lt) [ "$eq" != 1 -a "$vr" = "$vmax" ] && res=0;;
	\>=|ge) [ "$vl" = "$vmax" ] && res=0;;
	\<=|le) [ "$vr" = "$vmax" ] && res=0;;
	*) echo "$vl" | egrep -q "$vr"; res=$?;;
	esac

	return $res
}

create_vdisk() {
	local path=$1
	local size=$2
	local fstype=$3

	dd if=/dev/null of=$path bs=1${size//[0-9]/} seek=${size//[^0-9]/}
	local dev=$(losetup --partscan --show --find $path)
	printf "o\nn\np\n1\n\n\nw\n" | fdisk "$dev"
	mkfs.$fstype $MKFS_OPT "${dev}p1"
	losetup -d $dev
}

mount_vdisk() {
	local path=$1
	local mp=$2
	local partN=${3:-1}
	local offset=$(fdisk -l -o Start "$path" |
		awk -v N=$partN '
			/^Units:/ { unit=$(NF-1); offset=0; }
			/^Start/ {
				for(i=0;i<N;i++)
					if(getline == 0) { $0=""; break; }
				offset=$1*unit;
			}
			END { print offset; }'
	)
	echo "offset: $offset"

	[[ -d "$mp" ]] || {
		echo "{warn} mount_vdisk: dir '$mp' not exist"
		return 1
	}

	if [[ "$offset" -ne 0 || "$partN" -eq 1 ]]; then
		mount $MNT_OPT -oloop,offset=$offset $path $mp
	else
		echo "{warn} mount_vdisk: there's not part($partN) on disk $path"
		return 1
	fi
}

curl_download() {
	local filename=$1
	local url=$2
	shift 2;

	local curlopts="-f -L"
	local header=
	local fsizer=1
	local fsizel=0
	local rc=

	[[ -z "$filename" || -z "$url" ]] && {
		echo "Usage: curl_download <filename> <url> [curl options]" >&2
		return 1
	}

	header=$(curl -L -I -s $url|sed 's/\r//')
	fsizer=$(echo "$header"|awk '/Content-Length:/ {print $2; exit}')
	if echo "$header"|grep -q 'Accept-Ranges: bytes'; then
		curlopts+=' --continue-at -'
	fi

	echo "{VM:INFO} run: curl -o $filename $curl $curlopts $curlOpt $@"
	curl -o $filename $url $curlopts $curlOpt "$@"
	rc=$?
	if [[ $rc != 0 && -s $filename ]]; then
		fsizel=$(stat --printf %s $filename)
		if [[ $fsizer -le $fsizel ]]; then
			echo "{VM:INFO} *** '$filename' already exist $fsizel/$fsizer"
			rc=0
		fi
	fi

	return $rc
}
curl_download_x() { until curl_download "$@"; do sleep 1; done; }

#-------------------------------------------------------------------------------

install_requires() {
	. /etc/os-release
	OS=$NAME

	echo -e "{VM:INFO} checking libvirtd service and related packages ..."
	case ${OS,,} in
	fedora*|red?hat*|centos*|rocky*)
		local pkglist="bash-completion libvirt libvirt-client virt-install virt-viewer qemu-kvm expect nmap-ncat tmux libguestfs-tools-c libvirt-nss dialog qemu-img genisoimage iptables-nft"
		if ! egrep -q '^!?epel' < <(yum repolist 2>/dev/null); then
			OSV=$(rpm -E %rhel)
			[[ "$OSV" != "%rhel" ]] && yum $yumOpt install -y https://dl.fedoraproject.org/pub/epel/epel-release-latest-${OSV}.noarch.rpm 2>/dev/null
		fi
		rpm -q $pkglist || {
			sudo yum $yumOpt --setopt=strict=0 install -y $pkglist
		}
		;;
	debian*|ubuntu*)
		local pkglist="bash-completion libnss-libvirt libvirt-clients libvirt-daemon libvirt-daemon-system dnsmasq qemu-kvm virtinst expect netcat tmux libguestfs-tools dialog qemu-utils genisoimage nftables acl"
		read -d . verx 2>/dev/null </etc/debian_version
		[[ "$verx" = 9 ]] && {
			sudo apt -y update; sudo apt -y upgrade
			sudo apt install -o APT::Install-Suggests=0 -o APT::Install-Recommends=0 busybox-static
		}
		sudo apt install -o APT::Install-Suggests=0 -o APT::Install-Recommends=0 --ignore-missing -y $pkglist
		;;
	opensuse*|sles*)
		pkglist="bash-completion libvirt libvirt-client virt-install virt-viewer qemu-kvm expect netcat tmux libguestfs libvirt-nss dialog qemu-tools mkisofs iptables-nft"
		sudo zypper in --no-recommends -y $pkglist
		;;
	*)
		: #fixme add more platform
		echo -e "{VM:WARN} kiss-vm doesn't supported this platform($OS)"
		return 2
		;;
	esac
}

prepare_libvirt() {
	local force=$1
	local sudouser=${SUDO_USER:-$(whoami)}
	eval sudouserhome=~$sudouser
	if [[ -n "$force" ]]; then
		echo -e "{VM:INFO} force re-prepare kiss-vm env"
	else
		if [[ -d $perConfDir ]]; then
			[[ "$ONLY_PREPARE" = yes ]] && echo -e "{VM:INFO} kiss-vm has been initialized."
			return 0
		fi
	fi

	echo -e "~~~~~~~~~~~~~~~~~~~~~~~~~~~~ prepare libvirt start ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
	test $(id -u) = 0 || { echo "{VM:Error} vm prepare need root permission, try: sudo $P prepare" >&2; exit 1; }

	#install packages required by kiss-vm
	install_requires; [[ $? = 2 ]] && return 1

	#install packages(gm,gocr,vncdo) required by vnc -get -put --putln options
	echo -e "{VM:INFO} install gm gocr and vncdo ..."
	_file=ggv-install.sh
	if ! command -v $_file >/dev/null; then
		_url=$baseUrl/utils/$_file
		curl_download /usr/bin/$_file $_url && chmod +x /usr/bin/$_file
	fi
	ggv-install.sh

	echo -e "{VM:INFO} configure libvirt-nss ..."
	grep -q '^hosts:.*libvirt libvirt_guest' /etc/nsswitch.conf || {
		echo -e "{*INFO*} you have not configure /etc/nsswitch.conf, trying sed ..."
		sed -ri '/^hosts:/s/files /&libvirt libvirt_guest /' /etc/nsswitch.conf
	}

	virtdconf=/etc/libvirt/libvirtd.conf
	echo -e "{VM:INFO} checking value of 'unix_sock_group' and 'unix_sock_rw_perms' in $virtdconf ..."
	ls $virtdconf &>/dev/null || chmod +x /etc/libvirt
	awk '/^unix_sock_group = "libvirt"/{c++} /^unix_sock_rw_perms = "0770"/{c++} END {rc=1; if(c==2) rc=0; exit rc}' $virtdconf || {
		echo -e "{*INFO*} confiure $virtdconf ..."
		sh -c "
			sed -ri -e '/#unix_sock_group = \"libvirt\"/s/^#//' -e '/#unix_sock_rw_perms = \"0770\"/s/^#//' $virtdconf
			egrep -e ^unix_sock_group -e ^unix_sock_rw_perms $virtdconf
			systemctl restart libvirtd && systemctl restart virtlogd
		"
	}

	pvirtconf=$sudouserhome/.config/libvirt/libvirt.conf
	su $sudouser -s /bin/bash -c "mkdir -p ${pvirtconf%/*}"
	su $sudouser -s /bin/bash -c "virsh net-info default &>/dev/null && grep -q -w default <(virsh net-list --name)" || {
		#export LIBVIRT_DEFAULT_URI=qemu:///system
		echo 'uri_default = "qemu:///system"' >>$pvirtconf
	}

: <<'COMM'
	qemuconf=/etc/libvirt/qemu.conf
	eval echo -e "{VM:INFO} checking if qemu can read image in ~$sudouser ..."
	egrep -q '^#(user|group) =' "$qemuconf" && {
		sed -i '/^#(user|group) =/s/^#//' "$qemuconf"
	}
COMM

	su $sudouser -s /bin/bash -c "mkdir -p $VMSHOME"

	{ _user=qemu; id qemu 2>/dev/null || _user=libvirt-qemu; }
	echo -e "{VM:INFO} setfacl -mu:${_user}:rx $sudouserhome ..."
	setfacl -mu:${_user}:rx $sudouserhome
	setfacl -mu:${_user}:rx -R $VMSHOME
	setfacl -mu:${_user}:rx -R $sudouserhome/.cache/virt-manager 2>/dev/null
	getfacl $sudouserhome
	getfacl $VMSHOME

	echo -e "{VM:INFO} checking if ${sudouser} has joined group libvirt ..."
	[[ $(id -u $sudouser) != 0 ]] && {
		if ! id -Gn $sudouser | egrep -q -w libvirt; then
			if getent group libvirt|egrep -q -w $sudouser; then
				: #do nothing
			else
				echo -e "{*INFO*} run: usermod -a -G libvirt $sudouser ..."
				usermod -a -G libvirt $sudouser  #or gpasswd -a $sudouser libvirt
			fi
		fi
	}

	#re-define default network, if 192.168.122.0 has been used by other ifs
	grep -q 'Network is already in use' < <(virsh net-start default 2>&1 >/dev/null) && {
		default_xml=$(virsh net-dumpxml default|sed 's/\.122/.123/g')
		{ virsh net-destroy -- default; virsh net-undefine -- default; } &>/dev/null
		virsh net-define --file <(echo "$default_xml")
		virsh net-start default
		virsh net-autostart default
	}

	su $sudouser -s /bin/bash -c "mkdir -p $perConfDir"
	echo -e "~~~~~~~~~~~~~~~~~~~~~~~~~~~~ prepare libvirt done! ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
	[[ -z "$force" ]] && printf '\33[H\33[2J'
}

is_available_url() {
	local _url=$1
	curl --connect-timeout 8 -m 16 --output /dev/null --silent --head --fail $_url &>/dev/null
}
is_intranet() {
	local iurl=http://$downhostname
	is_available_url $iurl 
}

# functions that work in Intranet
if [[ $Intranet = yes ]]; then
	install_distro_compose() {
		local _file=distro-compose
		command -v $_file >/dev/null || {
			_url=$bkrClientImprovedUrl/utils/$_file
			mkdir -p ~/bin && curl_download ~/bin/$_file $_url && chmod +x ~/bin/$_file
		}
	}
	fetch_distro_list() {
		install_distro_compose
		distro-compose --distrolist
	}
	fetch_distro_trees() {
		local distro=$1
		local arch=$2
		local dtrees=

		#dtrees=$(bkr distro-trees-list --name "$distro" --arch "$arch"|egrep '(released|compose)')
		install_distro_compose
		dtrees=$(distro-compose -d "$distro" --distrotrees|egrep "(released|compose).*${arch}")

		[[ -z "$dtrees" ]] &&
			dtrees=$(distro-compose -d "$distro" --distrotrees|egrep "(Everything).*${arch}")
		echo "$dtrees"
	}
	distro2location() {
		local distro=$1
		local variant=${2:-Server}
		local arch=$(arch)

		distrotrees=$(fetch_distro_trees $distro $arch)
		[[ -z "$distrotrees" ]] && return 1

		urls=$(echo "$distrotrees" | awk '$3 ~ /https?:.*'"(${variant}|BaseOS|Everything)"'/{print $3}' | sort -u)
		echo -e "\n====\n$urls\n====\n" >&2

		local _file=fastesturl.sh
		command -v $_file >/dev/null || {
			_url=$baseUrl/utils/$_file
			mkdir -p ~/bin && curl_download ~/bin/$_file $_url && chmod +x ~/bin/$_file
		}
		$_file $urls
	}
	getimageurls() {
		local parenturl=$1
		local suffix_pattern=$2
		local rc=1

		local imagenames=$(curl -L -s ${parenturl} | sed -nr '/.*"([^"]+'"${suffix_pattern}"')".*/{s//\1/;p}')
		local qcow2Imgs= rawImgs= otherImgs=

		local arch=$(arch)
		[[ $arch = aarch64 || $arch = arm64 ]] && arch="(aarch64|arm64)"
		[[ $arch = x86_64 || $arch = amd64 ]] && arch="(x86_64|amd64)"
		imgs=$(egrep "$arch" <<< "$imagenames")
		[[ -n "$imgs" ]] && imagenames="$imgs"

		for imagename in $imagenames; do
			case $imagename in
			*qcow2*) qcow2Imgs+=$imagename$'\n';;
			*raw*)   rawImgs+=$imagename$'\n';;
			*)       otherImgs+=$imagename$'\n';;
			esac
		done

		[[ -n "$qcow2Imgs" ]] && rawImgs=
		[[ -n "$rawImgs" ]] && otherImgs=

		for image in $qcow2Imgs $rawImgs $otherImgs; do
			echo -e "{VM:INFO} image: $image" >&2
			if [[ -n "${image}" ]]; then
				[[ "${image}" = *Atomic* ]] && continue
				[[ "${image}" = *-ec2* ]] && continue
				[[ "${image}" = *-nocloud* ]] && continue
				echo ${parenturl%/}/${image}
				rc=0
			fi
		done
		return $rc
	}

	distro2repos() {
		local distro=$1
		local url=$2
		local Repos=()
		local _cdnhost="cdn.stage.fedorahat.com"

		if ! is_available_url $url; then
			return 1
		fi

		shopt -s nocasematch
		case ${distro,,} in
		rhel-5*|rhel5*)
			{ read; read os arch verytag verxosv _; } < <(tac -s ' ' <<<"${url//\// }")
			debug_url=${url/\/os/\/debug}
			osv=${verxosv#RHEL-5-}
			Repos+=(
				Server:${url}/Server
				Cluster:${url}/Cluster
				ClusterStorage:${url}/ClusterStorage
				Client:${url}/Client
				Workstation:${url}/Workstation

				${osv}-debuginfo:${debug_url}
			)
			;;

		rhel-6*|rhel6*|centos6*|centos-6*)
			{ read; read os arch osv ver _; } < <(tac -s ' ' <<<"${url//\// }")
			debug_url=${url/\/os/\/debug}
			Repos+=(
				${osv}:${url}
				${osv}-SAP:${url/$osv/${osv}-SAP}
				${osv}-SAPHAHA:${url/$osv/${osv}-SAPHAHA}

				${osv}-debuginfo:${debug_url}
				${osv}-SAP-debuginfo:${debug_url/$osv/${osv}-SAP}
				${osv}-SAPHAHA-debuginfo:${debug_url/$osv/${osv}-SAPHAHA}
				extras:http://${_cdnhost/fedora/red}/content/dist/rhel/server/6/6Server/$(arch)/extras/os
				cdn_os:http://${_cdnhost/fedora/red}/content/dist/rhel/server/6/6Server/$(arch)/os
			)
			;;
		rhel-7*|rhel7*|centos7*|centos-7*)
			{ read; read os arch osv ver _; } < <(tac -s ' ' <<<"${url//\// }")
			debug_url=${url/\/os/\/debug\/tree}
			Repos+=(
				${osv}:${url}
				${osv}-optional:${url/$osv/${osv}-optional}
				${osv}-NFV:${url/$osv/${osv}-NFV}
				${osv}-RT:${url/$osv/${osv}-RT}
				${osv}-SAP:${url/$osv/${osv}-SAP}
				${osv}-SAPHAHA:${url/$osv/${osv}-SAPHAHA}

				${osv}-debuginfo:${debug_url}
				${osv}-optional-debuginfo:${debug_url/$osv/${osv}-optional}
				${osv}-NFV-debuginfo:${debug_url/$osv/${osv}-NFV}
				${osv}-RT-debuginfo:${debug_url/$osv/${osv}-RT}
				${osv}-SAP-debuginfo:${debug_url/$osv/${osv}-SAP}
				${osv}-SAPHAHA-debuginfo:${debug_url/$osv/${osv}-SAPHAHA}
				extras:http://${_cdnhost/fedora/red}/content/dist/rhel/server/7/7Server/$(arch)/extras/os
				cdn_os:http://${_cdnhost/fedora/red}/content/dist/rhel/server/7/7Server/$(arch)/os
				beaker-harness:https://$downhostname/beakerrepos/harness/RedHatEnterpriseLinux7
			)
			;;
		rhel-8*|rhel8*)
			{ read; read os arch osv ver _; } < <(tac -s ' ' <<<"${url//\// }")
			debug_url=${url/\/os/\/debug\/tree}
			read dtype distro <<< $(awk -F/+ '{
				for (i=3;i<NF;i++) { if ($(i+1) ~ /RHEL-/) {
					d=$(i+1)
					if (d ~ /RHEL-[0-9]$/) d=$(i+2)
					print($i, d); break }
				}
			}' <<<"$url")
			read prefix ver time <<< ${distro//-/ }
			[[ "$dtype" =~ rel-eng|nightly ]] || dtype=nightly
			Repos+=(
				BaseOS:${url}
				AppStream:${url/BaseOS/AppStream}
				CRB:${url/BaseOS/CRB}
				HighAvailability:${url/BaseOS/HighAvailability}
				NFV:${url/BaseOS/NFV}
				ResilientStorage:${url/BaseOS/ResilientStorage}
				RT:${url/BaseOS/RT}
				SAP:${url/BaseOS/SAP}
				SAPHANA:${url/BaseOS/SAPHANA}

				BaseOS-debuginfo:${debug_url}
				AppStream-debuginfo:${debug_url/BaseOS/AppStream}
				CRB-debuginfo:${debug_url/BaseOS/CRB}
				HighAvailability-debuginfo:${debug_url/BaseOS/HighAvailability}
				NFV-debuginfo:${debug_url/BaseOS/NFV}
				ResilientStorage-debuginfo:${debug_url/BaseOS/ResilientStorage}
				RT-debuginfo:${debug_url/BaseOS/RT}
				SAP-debuginfo:${debug_url/BaseOS/SAP}
				SAPHANA-debuginfo:${debug_url/BaseOS/SAPHANA}
				Buildroot:http://$downhostname/rhel-8/$dtype/BUILDROOT-8/latest-BUILDROOT-$ver-RHEL-8/compose/Buildroot/$arch/os
				beaker-harness:https://$downhostname/beakerrepos/harness/RedHatEnterpriseLinux8
			)
			;;
		rhel-9*|rhel9*)
			{ read; read os arch osv ver _; } < <(tac -s ' ' <<<"${url//\// }")
			debug_url=${url/\/os/\/debug\/tree}
			read dtype distro <<< $(awk -F/+ '{
				for (i=3;i<NF;i++) { if ($(i+1) ~ /RHEL-/) {
					d=$(i+1)
					if (d ~ /RHEL-[0-9]$/) d=$(i+2)
					print($i, d); break }
				}
			}' <<<"$url")
			read prefix ver time <<< ${distro//-/ }
			dtype=nightly
			Repos+=(
				BaseOS:${url}
				AppStream:${url/BaseOS/AppStream}
				CRB:${url/BaseOS/CRB}
				HighAvailability:${url/BaseOS/HighAvailability}
				NFV:${url/BaseOS/NFV}
				ResilientStorage:${url/BaseOS/ResilientStorage}
				RT:${url/BaseOS/RT}
				SAP:${url/BaseOS/SAP}
				SAPHANA:${url/BaseOS/SAPHANA}

				BaseOS-debuginfo:${debug_url}
				AppStream-debuginfo:${debug_url/BaseOS/AppStream}
				CRB-debuginfo:${debug_url/BaseOS/CRB}
				HighAvailability-debuginfo:${debug_url/BaseOS/HighAvailability}
				NFV-debuginfo:${debug_url/BaseOS/NFV}
				ResilientStorage-debuginfo:${debug_url/BaseOS/ResilientStorage}
				RT-debuginfo:${debug_url/BaseOS/RT}
				SAP-debuginfo:${debug_url/BaseOS/SAP}
				SAPHANA-debuginfo:${debug_url/BaseOS/SAPHANA}
				Buildroot:http://$downhostname/rhel-9/$dtype/BUILDROOT-9/latest-BUILDROOT-$ver/compose/Buildroot/$arch/os
				beaker-harness:https://$downhostname/beakerrepos/harness/RedHatEnterpriseLinux8
			)
			;;
		esac
		shopt -u nocasematch

		for repo in "${Repos[@]}"; do
			read _name _url <<<"${repo/:/ }"
			is_available_url $_url &&
				echo "$repo"
		done
	}
fi

Usage() {
	cat <<-'EOF'
	Usage:
	  vm [create] <distro_or_family_name> [OPTIONs] ...
	  vm <$other_subcmd> [OPTIONs] ...

	Options:
	  -h,--help      #Display this help.

	Options for sub-command create:
	  -I             #create VM by import existing disk image, auto search url according distro name
	  -i <url/path>  #create VM by import existing disk image, value can be url or local path
	  -L             #create VM by using location, auto search url according distro name
	  -l <url/path>  #create VM by using specified location url or local iso file path
	  -C <iso path>  #create VM by using ISO image
	  --ks <file>    #kickstart file, will auto generate according distro name if omitting
	  -n,--vmname <name>
	                 #VM name, will auto generate according distro name if omitting
	  -f,--force     #over write existing VM with same name
	  -p,--pkginstall <pkgs>
	                 #pkgs in default system repo, install by yum/apt/zypper/pacman
	  -b,--brewinstall <args>
	                 #pkgs in brew system or specified by url, install by internal brewinstall.sh
	                  `-> just could be used in Intranet
	  -g,--genimage  #generate VM image, after install shutdown VM and generate new qcow2.xz file
	  --rm           #like --rm option of docker/podman, remove VM after quit from console
	  --nocloud,--nocloud-init
	                 #don't create cloud-init iso for the image that is not cloud image
	  --osv <variant>
	                 #OS_VARIANT, optional. virt-install will attempt to auto detect this value
	                 # you can get [-osv variant] info by using:
	                 $ osinfo-query os  #RHEL-7 and later
	                 $ virt-install --os-variant list  #RHEL-6
	  --nointeract   #exit from virsh console after install finish
	  --noauto       #enter virsh console after installing start
	  --saveimage [path]
	                 #save image in path if install with import mode
	  --downloadonly #download image only if there is qcow* image
	  --cpus <N>     #number of virtual cpus, default 4
	  --msize <size> #memory size, default 2048
	  --dsize <size> #disk size, default 16
	  --net <$name[,$model]>
	                 #attach tun dev(vnetN) and connect to net $name, optional $model: virtio,e1000,...
	  --net-br <$brname[,$model]>
	                 #attach tun dev(vnetN) and connect to bridge $brname, optional $model: virtio,e1000,...
	  --net-macvtap,--netmacvtap [$sourceNIC[,$model]]
	                 #attach macvtap interface over $sourceNIC, optional $model: virtio,e1000,...
	  --macvtapmode <vepa|bridge>
	                 #macvtap mode
	  --xdisk <size[,fstype]>
	                 #add an extra disk, could be specified multi-times. size unit is G
	                 #`e.g: --xdisk 10 --xdisk 20,xfs
	  --disk <img[,bus=]>
	                 #add exist disk file, could be specified multi-times.
	  --bus <$boot_disk_bus>
	  --sharedir <shpath[:target]>
	                 #share path between host and guest
	  --nvdimm <nvdimm list>
	                 #one or more nvdimm specification, format: 511+1 (targetSize+labelSize)
	                 #`e.g: --nvdimm="511+1 1023+1" -> two nvdimm device
	                 #`e.g: --nvdimm="511 1023" -> two nvdimm device
	                 #               ^^^^^^^^ default labelSize is 1, if omitting
	                 #Note: will exit if qemu on your system does not support nvdimm, check by:
	                 # PATH=$PATH:/usr/libexec qemu-kvm -device help | grep nvdimm
	  --nvme <size=[,format=]>
	                 #one or more nvme specification.
	                 #`e.g: --nvme=size=10 --nvme=size=20,format=raw
	                 #size units: GB, default format is qcow2
	                 #Note: will exit if qemu on your system does not support nvme, check by:
	                 # PATH=$PATH:/usr/libexec qemu-kvm -device help | grep nvme
	  --vtpm         #enable virtual tpm
	  --kdump        #enable kdump
	  --fips         #enable fips
	  --postrepo <name:url>
	                 #add dnf/yum <repo> after install, only for CentOS/RHEL/Fedora
	                 #`e.g: --postrepo=beaker-tasks:http://beaker.engineering.fedora.com/rpms
	  --repo <name:url>
	                 #add dnf/yum <repo> before install, only for CentOS/RHEL/Fedora
	  --nosshkey     #don't inject sshkey
	  --debug        #debug mode
	  --vncput-after-install <msg>
	                 #send string or key event ASAP after virt-intall
	  --xml          #just generate xml
	  --machine <machine type>
	                 #specify machine type #get supported type by: qemu-kvm -machine help
	  --hostdev,--host-device <device from "virsh nodedev-list">
	                 #passthrough host device to KVM Guest
	                 #see also: virt-install --hostdev=?
	  --hostif,--hostnic,--host-nic <NIC name from "ip -br -c a show">
	                 #passthrough host (pci) NIC to KVM Guest
	  --virt-install-opts #Pass-through virt-install options
	  --qemu-opts    #Pass-through qemu options
	  --qemu-env     #Pass-through qemu env[s]
	  --enable-guest-hypv #enable guest hypervisor, same as --qemu-opts="-cpu host,+vmx" or --qemu-opts="-cpu host,+svm"
	                      #ref: https://www.linux-kvm.org/page/Nested_Guests
	  --disable-guest-hypv #disable guest hypervisor
	  --pxe          #PXE install
	                 #`e.g: vm fedora-32 -n f32 -net-macvtap -pxe --noauto -f
	  --diskless     #diskless install
	                 #`e.g: vm fedora-32 -n f32-diskless --net pxenet --pxe --diskless -f
	  -v,--verbose   #verbose mode
	  -q             #quiet mode, intend suppress the outputs of command yum, curl
	  --reboot       #reboot after vm create/install. for kernel update or ...
	                 #`e.g: vm create RHEL-8.4 -n nfs-client --repo=rname:url -p kernel-4.18.0-306.el8.bz9527 --reboot
	  --default-kernel <regex-pattern>
	                 #set default kernel, and reboot
	                 #`e.g: vm create RHEL-8.4 -n nfs-client --repo=rname:url -p kernel-4.18.0-306.el8.bz9527 --default-kernel=bz9527

	Options for sub-command reboot:
	  -w,--wait      #wait util the 22 port(sshd) is available after reboot

	Options for sub-command exec:
	  -v,--verbose   #verbose mode
	  -x[arg]        #expected return code of sub-command exec, if doesn't match output test fail msg
	                 #`e.g: -x  or  -x0  or  -x1,2,3  or  -x1,10,100-200

	Options for sub-command vncproc:
	  --get,--vncget #get vnc screen and convert to text by gocr
	  --getsc,--vncgetsc
	                 #get vnc screen
	  --put,--vncput <msg>
	                 #send string or key event to vnc server, could be specified multi-times
	                 #`e.g: --put root --put key:enter --put password --put key:enter
	  --putln,--vncputln <msg>
	                 #alias of: --put msg --put key:enter

	EOF
	[[ "$Intranet" = yes ]] && cat <<-EOF
	Examples for create vm from distro-db (Intranet):
	  $P [create] # will enter a TUI show you all available distros that could auto generate source url
	  $P [create] RHEL-7.7                           # install RHEL-7.7 from cloud-image(by default)
	  $P [create] RHEL-6.10 -L                       # install RHEL-6.10 from Location(by -L option)

	  $P [create] RHEL-8.1.0 -f -p "vim wget git"    # -f force install VM and ship pkgs: vim wget git
	  $P [create] RHEL-8.1.0 -brewinstall 23822847   # ship brew scratch build pkg (by task id)
	  $P [create] RHEL-8.1.0 -brewinstall kernel-4.18.0-147.8.el8  # ship brew build pkg (by build name)
	  $P [create] RHEL-8.1.0 -brewinstall "lstk -debug"            # ship latest brew build release debug kernel
	  $P [create] RHEL-8.1.0 -brewinstall "upk -debug"             # ship latest brew build upstream debug kernel
	  $P [create] RHEL-8.1.0 --nvdimm "511 1022+2"                 # add two nvdimm device
	  $P [create] RHEL-8.3.0 --nvme "size=32 size=16,format=raw"   # add two nvme device
	  $P [create] rhel-8.2.0%                        # nightly 8.2 # fuzzy search distro: ignore-case
	  $P [create] rhel-8.2*-????????.?               # rtt 8.2     # - and only support glob * ? syntax, and SQL %(same as *)
	  $P [create] rhel-8.2% -enable-guest-hypv -msize=\$((8*1024)) -dsize=120  # enable hyper-v on guest

	EOF
	cat <<-EOF
	Examples for create vm from distro-db (Internet):
	  $P [create] # will enter a TUI show you all available distros that could auto generate source url
	  $P [create] CentOS-8-stream -b ftp://url/path/x.rpm
	  $P [create] CentOS-8 -p "jimtcl vim git make gcc"
	  $P [create] CentOS-7 -p "vim git wget make gcc"
	  $P [create] FreeBSD-13.0
	  $P [create] debian-10
	  $P [create] openSUSE-leap-15.2
	  $P [create] fedora-32
	  $P [create] CentOS-8 -enable-guest-hypv -msize=\$((8*1024)) -dsize=120  # enable hyper-v on guest

	Examples for create vm from local image or url:
	  $P [create] freebsd-130 -i ~/myimages/download/FreeBSD-13.0-RELEASE-amd64.qcow2.xz --nocloud-init
	  $P [create] debian-10 -i /mnt/vm-images/debian-10-openstack-amd64.qcow2
	  $P [create] openSUSE-15.2 -i ~/myimages/openSUSE-Leap-15.2-OpenStack.x86_64.qcow2
	  $P [create] debian-test -i https://cdimage.debian.org/cdimage/openstack/testing/debian-testing-openstack-amd64.qcow2
	  $P [create] centos-8 -l https://cloud.centos.org/centos/8/x86_64/images/
	  $P [create] rhel-8.4.0 -l ~/myimages/download/RHEL-8.4.0-any-x86_64-dvd1.iso -n rhel84-from-iso

	Examples for other sub-commands:
	  $P prepare           #check/install/configure libvirt and other dependent packages
	  $P enable-nested-vm  #enable nested on host

	  $P list              #list all VMs       //you can use ls,li,lis* instead list
	  $P login [VM]        #login VM via ssh   //you can use l,lo,log* instead login
	  $P console [VM]      #log VM via console //you can use co,con,cons* instead console
	  $P delete [VM list]  #delete VMs         //you can use d,de,del*,r,rm instead delete
	  $P ifaddr [VM]       #show ip address    //you can use i,if,if* instead ifaddr
	  $P vnc [VM]          #show vnc host:port //you can use v,vn instead
	  $P vnc [-get|-put|-putln] [VM]           #read screen text or send string thru vnc
	  $P xml [VM]          #dump vm xml file   //you can use x,xm instead xml
	  $P edit [VM]         #edit vm xml file   //you can use ed,ed* instead edit
	  $P exec [-v] [-x] "\$VM" -- "cmd"  #login VM and exec cmd  //you can use e,ex,ex* instead exec
	  $P reboot [-w] [VM]  #reboot VM          //option /w indicate wait until reboot complete(port 22 is available)
	  $P stop [VM]         #stop/shutdonw VM   //nil
	  $P start [VM]        #start VM           //nil
	  $P cpfrom <VM> <file/dir_in_vm> <dst_dir/file_in_host>
	  $P cpto   <VM> <files/dirs_in_host ...> <dst_dir_in_vm>

	  $P netls             #list all virtual network
	  $P netcreat netname=nat-net brname=virbrM subnet=10 [forward=nat]  #create network 'nat-net' with 'nat' and subnet: 192.168.10.0
	  $P netcreat netname=isolated-net brname=virbrN subnet=20 forward=no  #create network 'isolated-net' with subnet: 192.168.20.0
	  $P netcreat netname=pxe brname=virpxebrN subnet=172.25.250.0 tftproot=/var/lib/tftpboot bootpfile=pxelinux/pxelinux.0
	  $P netinfo netname   #show detail info of virtual network 'netname'
	  $P netstart netname  #start virtual network 'netname'
	  $P netdel netname    #delete virtual network 'netname'
	EOF
}

run() {
	[[ $# -eq 0 ]] && return 0

	[[ "$DEBUG" = yes ]] && echo "[sys]" "$@"
	"$@"
}

expandrc() {
	local rcrange=$1
	local rclist=()
	for rc in ${rcrange//,/ }; do
		if [[ "$rc" =~ ^[0-9]+$ ]]; then
			rclist+=($rc)
		elif [[ "$rc" =~ ^[0-9]+-[0-9]+$ ]]; then
			eval rclist+=({${rc/-/..}})
		fi
	done
	echo -n ${rclist[@]}
}

is_bridge() {
	local ifname=$1
	[[ -z "$ifname" ]] && return 1
	ip -d a s $ifname | grep -qw bridge
}

get_default_if() {
	local notbr=$1  #indicate get real NIC not bridge
	local _iface= iface=
	local type=

	ifaces=$(ip route | awk '/^default/{print $5}')
	for _iface in $ifaces; do
		type=$(ip -d link show dev $_iface|sed -n '3{s/^\s*//; p}')
		[[ -z "$type" || "$type" = altname* || "$type" = bridge* ]] && {
			iface=$_iface
			break
		}
	done
	if [[ -n "$notbr" ]] && is_bridge $iface; then
		# ls /sys/class/net/$iface/brif
		if command -v brctl >/dev/null; then
			brctl show $iface | awk 'NR==2 {print $4}'
		else
			ip link show type bridge_slave | awk -F'[ :]+' '/master '$iface' state UP/{print $2}' | head -n1
		fi
		return 0
	fi
	echo $iface
}

# command line parse
orig_at=("$@")
_at=`getopt -o hd:Ll:C:fn:gb:p:Ii:rvdx::Pqw \
	--long help \
	--long prepare \
	--long enable-nested-vm \
	--long debug \
	--long ks: \
	--long rm \
	--long osv: \
	--long os-variant: \
	--long force \
	--long vmname: \
	--long genimage \
	--long xzopt: \
	--long brewinstall: \
	--long pkginstall: \
	--long geturl \
	--long getvmname \
	--long nocloud-init --long nocloud \
	--long cpus: \
	--long msize: \
	--long dsize: \
	--long net: \
	--long net-br: \
	--long net-macvtap:: --long netmacvtap:: \
	--long macvtapmode: \
	--long nointeract \
	--long noauto \
	--long saveimage:: --long sa:: \
	--long downloadonly \
	--long ready \
	--long bus: \
	--long xdisk: \
	--long disk: \
	--long sharedir: \
	--long nvdimm: \
	--long nvme: \
	--long vtpm \
	--long kdump \
	--long fips \
	--long postrepo: \
	--long repo: \
	--long nosshkey \
	--long getsc --long vncgetsc \
	--long get --long vncget \
	--long put: --long vncput: \
	--long putln: --long vncputln: \
	--long vncput-after-install: \
	--long xml \
	--long machine: \
	--long hostdev: --long host-device: \
	--long hostif: --long hostnic: --long host-nic: \
	--long virt-install-opts: \
	--long qemu-opts: \
	--long qemu-env: \
	--long enable-guest-hypv \
	--long disable-guest-hypv \
	--long pxe \
	--long diskless \
	--long verbose \
	--long reboot \
	--long default-kernel: \
	--long wait \
    -a -n "$0" -- "$@"`
[[ $? != 0 ]] && { exit 1; }
eval set -- "$_at"
while true; do
	case "$1" in
	-h|--help) Usage; shift 1; exit 0;;
	--prepare) ONLY_PREPARE=yes; shift 1;;
	--enable-nested-vm) ENABLE_NESTED=yes; shift 1;;
	-d)        Distro=$2; shift 2;;
	-C)        InstallType=cdrom; Isourl=$2; shift 2;;
	-l)        InstallType=location; Location=$2; shift 2;;
	-L)        InstallType=location; shift 1;;
	-i)        InstallType=import; ImportImageInfo=${2}; shift 2;;
	-I)        InstallType=import; shift 1;;
	-P|--pxe)  InstallType=pxe; shift 1;;
	--diskless) DISKLESS=yes; shift 1;;
	--ks)      KSPath=$2; shift 2;;
	--rm)      RM=yes; shift 1;;
	--xzopt)          XZ="$2"; shift 2;;
	-f|--force)       OVERWRITE="yes"; FORCE=yes; shift 1;;
	-n|--vmname)      VMName="$2"; shift 2;;
	-g|--genimage)    GenerateImage=yes; shift 1;;
	--geturl)         OnlyGetUrl=yes; shift 1;;
	--getvmname)      OnlyGetVMName=yes; shift 1;;
	-b|--brewinstall) BPKGS+=" $2"; shift 2;;
	-p|--pkginstall)  PKGS+=" $2"; shift 2;;
	--osv|--os-variant) VM_OS_VARIANT="$2"; shift 2;;
	--nocloud*)      NO_CLOUD_INIT="yes"; shift 1;;
	--dsize)         dsizeflag=1; DSIZE="$2"; shift 2;;
	--msize)         MSIZE="$2"; shift 2;;
	--cpus)          VCPUS="$2"; shift 2;;
	--nointeract)    INTERACT="no"; shift 1;;
	--noauto)        NOAUTO="yes"; shift 1;;
	--net)
		read netname model <<<"${2/,/ }"
		NETWORK_OPTS+=" --network=network=$netname,model=${model:-virtio}"; shift 2;;
	--net-br)
		read brname model <<<"${2/,/ }"
		NETWORK_OPTS+=" --network=bridge=$brname,model=${model:-virtio}"; shift 2;;
	--net-macvtap|--netmacvtap)
		read srcif model <<<"${2/,/ }"
		[[ "$srcif" = - ]] && srcif=
		srcif=${srcif:-$(get_default_if)}
		NETWORK_OPTS+=" --network=type=direct,source=$srcif,source_mode=$MacvtapMode,model=${model:-virtio}"; shift 2;;
	--macvtapmode)   MacvtapMode="$2"; shift 2;;
	--saveimage|--sa)
		SAVE_IMAGE="yes"
		DownloadImagePath=${2:-$ImagePath/download}
		shift 2
		;;
	--downloadonly)  SAVE_IMAGE="yes"; DOWNLOAD_ONLY="yes"; InstallType=import; shift 1;;
	-r|--ready)      KISS_VM_READY=yes; shift 1;;
	--bus)           BOOT_DISK_BUS="$2"; shift 2;;
	--xdisk)         EXTRA_DISKS+=("$2"); shift 2;;
	--disk)          DISKS+=("$2"); shift 2;;
	--sharedir)      SHARE_DIRS+=("$2"); shift 2;;
	--nvdimm)        NVDIMM_LIST+=($2); shift 2;;
	--nvme)          NVME_DEVS+=($2); shift 2;;
	--vtpm)          VTPM=yes; shift 1;;
	--kdump)         kdump=yes; shift 1;;
	--fips)          fips=yes; shift 1;;
	--postrepo)      POST_REPOS+=("$2"); shift 2;;
	--repo)          _REPO_OPTS+=" --repo $2"; shift 2;;
	--nosshkey)      NO_SSHKEY=yes; shift 1;;
	--debug)         DEBUG=yes; shift 1;;
	--get|--vncget)  VNCGET=yes; shift 1;;
	--getsc|--vncgetsc) VNCGETSC=yes; shift 1;;
	--put|--vncput)  VNCPUTS+=("$2"); shift 2;;
	--putln|--vncputln)     [[ -n "$2" ]] && VNCPUTS+=("$2" "key:enter") || VNCPUTS+=("key:enter"); shift 2;;
	--vncput-after-install) VNCPUT_AFTER_INSTALL="$2"; shift 2;;
	--xml)           XML=--print-xml; shift 1;;
	--machine)       MACHINE_OPT="--machine=$2"; shift 2;;
	--hostdev|--host-device)    HOST_DEV_LIST+=("$2"); shift 2;;
	--hostif|--hostnic|--host-nic)  HOST_NIC_LIST+=("$2"); shift 2;;
	--virt-install-opts)    VIRT_INSTALL_OPTS+=("$2"); shift 2;;
	--qemu-opts)     QEMU_OPTS+=("--qemu-commandline=$2"); shift 2;;
	--qemu-env)      QEMU_ENV+=("--qemu-commandline=env=$2"); shift 2;;
	--enable-guest-hy*) ENABLE_L2VM=yes; shift 1;;
	--disable-guest-hy*) ENABLE_L2VM=no; shift 1;;
	-x) expectedRC=${2:-0}; expectedrc=$(expandrc ${expectedRC#=}); shift 2;;
	-v|--verbose)    VERBOSE=yes; shift 1;;
	-q)              QUIET=yes; shift 1;;
	--reboot)        REBOOT=yes; shift 1;;
	--default-kernel) DEFAULT_KERNEL="$2"; shift 2;;
	-w|--wait)       WAIT=yes; shift 1;;
	--) shift; break;;
	esac
done

libvirt_nvr() { echo -n "libvirt-$(virsh --version 2>/dev/null)"; }
QEMU_KVM=$(PATH=/usr/libexec:$PATH command -v qemu-kvm qemu-system-x86)
qemu_kvm() { echo -n qemu-kvm-$($QEMU_KVM --version 2>/dev/null | awk '{print $4; exit}'); }
if [[ "${#NVDIMM_LIST[@]}" -gt 0 ]]; then
	if ! grep -q nvdimm < <($QEMU_KVM -device help); then
		echo -e "{VM:WARN} $(qemu_kvm) doesn't support nvdimm driver."
		exit 1
	fi
fi
if [[ "${#NVME_DEVS[@]}" -gt 0 ]]; then
	if ! grep -q nvme < <($QEMU_KVM -device help); then
		echo -e "{VM:WARN} $(qemu_kvm) doesn't support nvme driver."
		exit 1
	fi
fi
if [[ ${#SHARE_DIRS[@]} -gt 0 ]]; then
	if vercmp "$(libvrt_ver)" lt libvirt-6.2; then
		echo -e "{VM:WARN} $(libvirt_nvr) doesn't support virtiofs driver that's required by --sharedir option."
		exit 1
	fi
fi
if [[ "$VTPM" = yes ]]; then
	_dependpkgs=swtpm-tools
	_dependcmd=swtpm_setup
	if ! grep -q tpm-crb < <($QEMU_KVM -device help); then
		echo -e "{VM:WARN} $(qemu_kvm) don't support tpm-crb driver that's required by --vtpm option"
		exit 1
	fi
	if ! command -v $_dependcmd 2>/dev/null; then
		echo -e "{VM:WARN} pkg $_dependpkgs is/are needed by vTPM function, please install $_dependpkgs first."
		exit 1
	fi
	VTPM_OPT="--tpm emulator,model=tpm-crb,version=2.0"
	PKGS+=" tpm2-tools"
fi

[[ "$QUIET" = yes ]] && {
	yumOpt=-q
	curlOpt=-s
}

# __main__
if egrep -q -wo '(vmx|svm)' /proc/cpuinfo || egrep -q 'CPU 0000%@' /proc/cpuinfo; then
	[[ "$1" = prepare ]] && {
		KISS_VM_READY=; ONLY_PREPARE=yes
		FORCE_PREPARE=$FORCE
	}
	[[ "$KISS_VM_READY" != yes ]] && {
		if [[ -t 1 ]]; then
			prepare_libvirt $FORCE_PREPARE &>/dev/tty
		else
			#echo -e "{VM:WARN} there's not /dev/tty file redirect prepare_libvirt msg to stderr" >&2
			prepare_libvirt $FORCE_PREPARE >&2
		fi
		[[ "$ONLY_PREPARE" = yes ]] && exit
	}

	#first time
	[[ $(id -u) != 0 ]] && {
		if ! id | egrep -qw libvirt; then
			expect <(cat <<-EOF
			set timeout -1
			log_user 0
			spawn -noecho newgrp libvirt
			expect "*\[>\$]" { send ": newgrp libvirt; $P ${orig_at[@]}; exit \$?\r"; interact; }
			foreach {pid spawnid os_error_flag value} [wait] break
			exit \$value
			EOF
			)
			exit $?
		fi
	}
else
	echo -e "{VM:WARN} current machine doesn't support Virtualization, show help info with\n  $PROG -h"
	exit 1
fi

enable_nested_kvm() {
	local kmodule=$(lsmod|awk '$1 == "kvm" {print $NF}')
	local vendor=${kmodule#kvm_}

	{
	echo "options kvm-$vendor nested=1"

	[[ "$vendor" = intel ]] && cat <<-EOF
	options kvm-$vendor enable_shadow_vmcs=1
	options kvm-$vendor enable_apicv=1
	options kvm-$vendor ept=1
	EOF
	} | sudo tee /etc/modprobe.d/kvm-nested.conf >/dev/null

	if [[ $(< /sys/module/$kmodule/parameters/nested) != [Yy1] ]]; then
		modprobe -r $kmodule || {
			echo -e "{VM:WARN} stop tasks are using module $kmodule, and try again"
			return 1
		}
		modprobe $kmodule
	fi
	cat /sys/module/$kmodule/parameters/nested
}
[[ "$ENABLE_NESTED" = yes ]] && {
	enable_nested_kvm
	exit $?
}

support_nested_kvm() {
	local kmodule=$(lsmod|awk '$1 == "kvm" {print $NF}')
	local paramf=/sys/module/$kmodule/parameters/nested
	local rc=0

	if [[ ! -f $paramf || $(< $paramf) != [Yy1] ]]; then
		rc=1
	fi
	return $rc
}
support_nested_kvm && ENABLE_L2VM=${ENABLE_L2VM:-yes}
[[ "$ENABLE_L2VM" = yes ]] && {
	kmodule=$(lsmod|awk '$1 == "kvm" {print $NF}')
	vendor=${kmodule#kvm_}
	case $vendor in
	intel) QEMU_OPTS+=("--qemu-commandline=-cpu host,+vmx");;
	amd) QEMU_OPTS+=("--qemu-commandline=-cpu host,+svm");;
	esac
}
virt-install -h | grep -q -- --qemu-commandline || QEMU_OPTS=()

mkdir -p $RuntimeTmp
mkdir -p ${DownloadImagePath}

# sub-command
[[ $P = vmc || $P = vm ]] || true && {
	subcmd=$1
	case "$subcmd" in
	h|\?|help) Usage|less; exit;;
	prepare) shift; [[ "$1" = -d ]] && shift; prepare_libvirt force; exit $?;;
	enable-nested-vm) shift; [[ "$1" = -d ]] && shift; enable_nested_kvm; exit $?;;
	create|creat) shift;;
	r|rm|d|de|del*) shift; [[ "$1" = -d ]] && shift; vmdelete "$@"; exit $?;;
	co|con|cons*) shift; [[ "$1" = -d ]] && shift; vmconsole "$@"; exit $?;;
	l|lo|log*) shift; [[ "$1" = -d ]] && shift; vmlogin "$@"; exit $?;;
	cpfrom|cpf*) shift; [[ "$1" = -d ]] && shift; vmcopyfrom "$@"; exit $?;;
	cpto|cpt*) shift; [[ "$1" = -d ]] && shift; vmcopyto "$@"; exit $?;;
	e|ex|ex*) shift; [[ "$1" = -d ]] && shift; vmexec "$@"; exit $?;;
	ls|li|lis|list) shift; [[ "$1" = -d ]] && shift; vmlist "$@"; exit $?;;
	i|if|if*) shift; [[ "$1" = -d ]] && shift; vmifaddr "$@"; exit $?;;
	v|vn|vnc|vncp*) shift; [[ "$1" = -d ]] && shift; vmvncproc "$@"; exit $?;;
	x|xm*) shift; [[ "$1" = -d ]] && shift; vmxml "$@"; exit $?;;
	ed|ed*) shift; [[ "$1" = -d ]] && shift; vmedit "$@"; exit $?;;
	reboot|reb|re*) shift; [[ "$1" = -d ]] && shift; vmreboot "$@"; exit $?;;
	stop|sto*) shift; [[ "$1" = -d ]] && shift; vmstop "$@"; exit $?;;
	start|sta*) shift; [[ "$1" = -d ]] && shift; vmstart "$@"; exit $?;;
	clone) shift; [[ "$1" = -d ]] && shift; vmclone "$@"; exit $?;;
	netls) shift; [[ "$1" = -d ]] && shift; netls "$@"; exit $?;;
	net|netcreat*) shift; [[ "$1" = -d ]] && shift; netcreate "$@"; exit $?;;
	netinfo) shift; [[ "$1" = -d ]] && shift; netinfo "$@"; exit $?;;
	netstart) shift; [[ "$1" = -d ]] && shift; netstart "$@"; exit $?;;
	netdel|netdelete) shift; [[ "$1" = -d ]] && shift; netdelete "$@"; exit $?;;
	esac
}
[[ -n "$VNCPUTS" || -n "$VNCGET" || -n "$VNCGETSC" ]] && { vmvncproc "$@"; exit $?; }

declare -A distroInfo
dbfile=/etc/kiss-vm/distro-db.bash
owndbfile=$perConfDir/distro-db.bash
[[ -f $dbfile ]] && {
	echo "{VM:INFO} load distro-db file $dbfile ..."
	source $dbfile
}
[[ -f $owndbfile ]] && {
	echo "{VM:INFO} load own distro-db file $owndbfile ..."
	source $owndbfile
}

if is_intranet; then
	timeout 2 hostname -A|grep -q '\.pek2\.' && downhostname=${downhostname/devel/eng.pek2}
	distroInfo[FreeBSD-13.0]="http://$downhostname/qa/rhts/lookaside/vm-images/FreeBSD-13.0/FreeBSD-13.0-RELEASE-amd64.qcow2.xz"
	distroInfo[FreeBSD-12.2]="http://$downhostname/qa/rhts/lookaside/vm-images/FreeBSD-12.2/FreeBSD-12.2-RELEASE-amd64.qcow2.xz"

	for _d in RHEL-7.{1..2} RHEL-6.{0..10} RHEL5-Server-U{10..11}; do
		distroInfo[$_d]="http://$downhostname/qa/rhts/lookaside/vm-images/$_d/"
	done
else
	Intranet=no
	baseUrl=https://raw.githubusercontent.com/tcler/kiss-vm-ns/master
	#bkrClientImprovedUrl=https://raw.githubusercontent.com/tcler/bkr-client-improved/master
fi

for disk in "${EXTRA_DISKS[@]}"; do
	read size fstype _ <<<"${disk//,/ }"
	[[ -n "$fstype" && $(id -u) -ne 0 ]] && {
		echo "{WARN} creating extra disk($disk) need super user permission, try:"
		echo "  sudo $0 ${_at[@]} $@"
		exit 1
	}
done

Imageurl=
BOOT_DISK_BUS=${BOOT_DISK_BUS:-virtio}
[[ -n "$ImportImageInfo" ]] && read Imageurl BOOT_DISK_ATTRS <<<"${ImportImageInfo/,/ }"
if [[ -n "$BOOT_DISK_ATTRS" ]]; then
	[[ "$BOOT_DISK_ATTRS" =~ bus= ]] || BOOT_DISK_ATTRS+=,bus=$BOOT_DISK_BUS
else
	BOOT_DISK_ATTRS=bus=$BOOT_DISK_BUS
fi

# Phase-0 get distro name
[[ -z "$Distro" ]] && Distro=$1
[[ -z "$Distro" ]] && {
	if [[ -z "$Location" && -z "$Imageurl" && -z "$Isourl" ]]; then
		distropatternInter=$RuntimeTmp/distroPatternInternet
		distropatternIntra=$RuntimeTmp/distroPatternIntranet
		distrolist=$RuntimeTmp/distroList
		dialogres=$RuntimeTmp/dialogRes
		touch $distropatternInter $distropatternIntra

		echo -e "Rocky\nCentOS\nfedora\ndebian\nopenSUSE\narchlinux\nFreeBSD" >>$distropatternInter
		for dname in "${!distroInfo[@]}"; do echo "$dname"; done >>$distrolist

		[[ "$Intranet" = yes ]] && {
			echo -e "Fedora\nRHEL-9\nRHEL-8\nRHEL-7\nRHEL-6\nRHEL5" >>$distropatternIntra
			fetch_distro_list >>$distrolist
		}

		familys=$(sed -e 's/.*/"&" "" 1/' $distropatternIntra $distropatternInter)
		dialog --backtitle "$0" --radiolist "please selet distro family/pattern:" 20 40 16 $familys 2>$dialogres || { Usage; exit 0; }
		pattern=$(head -n1 $dialogres|sed 's/"//g')
		dList=$(sed -e '/ /d' -e 's/.*/"&" "" 1/' $distrolist|egrep "$pattern")
		[[ "$Intranet" = yes ]] && grep -F "$pattern" $distropatternIntra && {
			dialog --title "If include nightly build" \
				--backtitle "Do you want nightly build distros?" \
				--yesno "Do you want nightly build distros?" 7 60
			[[ $? = 1 ]] && dList=$(echo "$dList"|grep -v '\.n\.[0-9]"')
		}
		dialog --backtitle "$0" --radiolist "please select distro:" 30 60 28 $dList 2>$dialogres || { Usage; exit 0; }
		Distro=$(head -n1 $dialogres|sed 's/"//g')
		printf '\33[H\33[2J'
	else
		Usage
		echo -e "\n{VM:WARN} ^^^ a distro name is necessary!\n"
		exit 1
	fi
}
[[ -z "$Distro" ]] && {
	echo -e "{VM:WARN} you have to select a distro name or specified it by adding command line parameter:\n"
	Usage
	exit 1
}

if egrep --color=always "[][~\!@#$^&()=,\":;{}|<>'\` ]" <<<"$Distro"; then
	echo -e "{VM:WARN} ^^^ invalid character[s] in distro name: '$Distro'"
	exit 1
fi

[[ "$Distro" = *[%*?]* ]] && {
	dpattern=${Distro//./\\.}
	dpattern=${dpattern//\?/.}
	dpattern=${dpattern//[%*]/.*}
	#_distro=$(fetch_distro_list | grep -i "^${dpattern}$" | head -1)
	_distro=$(fetch_distro_list | grep -i "^${dpattern}$" | head -2 | tail -1)
	[[ -n "$_distro" ]] && Distro="$_distro"
}

[[ -n "$VMName" ]] && vmprefix=

[[ "$OnlyGetVMName" = yes ]] && {
	vmname_gen $Distro $VMName
	exit $?
}

[[ -z "$OnlyGetUrl" ]] && {
	# check if VM exist
	vmname=$(vmname_gen $Distro $VMName)
	virsh desc $vmname &>/dev/null && {
		if [[ "${OVERWRITE}" = "yes" ]]; then
			echo "{VM:INFO} VM $vmname has been there, remove it ..."
			_vmdelete $vmname
		elif [[ "${DOWNLOAD_ONLY}" != "yes" ]]; then
			echo "{VM:INFO} VM $vmname has been there, if you want overwrite please use --force option"
			exit
		fi
	}
	vmhostname=$vmname
	[[ "$GenerateImage" = yes ]] && vmhostname=${vmname#${vmprefix}-}

	VMpath=$VMSHOME/$Distro/$vmname
	[[ "$InstallType" = pxe ]] && VMpath=$VMSHOME/PXE/$vmname
	mkdir -p $VMpath
}

# Phase-1: get distro's Location or Image url
_Imagepattern='(qcow2c|qcow2|qcow2.xz|raw|img)'
[[ -n "${distroInfo[$Distro]}" ]] && {
	echo -e "{VM:INFO} db: ${distroInfo[$Distro]}"
	read _Imageurl _Location <<<"${distroInfo[$Distro]}"
	[[ "$_Imageurl" = *%%* ]] && {
		read _Imageurl _Imagepattern <<<"${_Imageurl/\%\%/ }"
	}
	echo -e "{VM:INFO} db: $_Imageurl($_Imagepattern) $_Location"

	[[ -z "$Imageurl" ]] && Imageurl=${_Imageurl}
	[[ -z "$Location" ]] && Location=${_Location}
}

if [[ "$InstallType" = import ]]; then
	if [[ -n "$Imageurl" ]]; then
		if [[ ! -f $Imageurl ]]; then
			if ! is_available_url $Imageurl; then
				echo "{VM:WARN} '$Imageurl' is neither an image file nor an available url, exit .." >&2
				exit 2
			else
				: #do nothing
			fi
		fi

		if [[ $Intranet = yes ]]; then
			if [[ $Distro = RHEL-* || $Distro = Fedora-* ]]; then
				Location=$(distro2location $Distro 2>/dev/null)
			fi
		fi
	else
		if [[ $Intranet != yes ]]; then
			echo "{VM:WARN} can not find imageUrl of '$Distro' in database." >&2
			exit 1
		else
			echo "{VM:INFO} getting fastest location of $Distro ..." >&2
			Location=$(distro2location $Distro)
			[[ -z "$Location" ]] && {
				echo "{VM:WARN} can not find location info of '$Distro'" >&2
				exit 1
			}
			echo -e " -> $Location"
			echo "{VM:INFO} getting image url according location url ^^^ ..." >&2
			imageLocation=${Location/\/os\//\/images\/}
			[[ $Distro = Fedora-* ]] &&
				imageLocation=$(echo "$imageLocation" | sed -r 's;/[Ss]erver|Everything/;/Cloud/;')
			is_available_url $imageLocation ||
				imageLocation=${imageLocation/Cloud/CloudImages}
			read Imageurl _ < <(getimageurls $imageLocation "${_Imagepattern}"|sort -Vr)
			if [[ $? != 0 ]]; then
				echo "{VM:INFO} can not find imageUrl of '$Distro' in database, switching to Location mode" >&2
				InstallType=location
				Imageurl=
			fi
		fi
	fi

	# if not swithed to Location mode
	if [[ "$InstallType" = import ]]; then
		if [[ ! -f "$Imageurl" ]]; then
			if ! egrep -q '\.(qcow2c|qcow2|qcow2.xz|raw|img)$' <<<"$Imageurl"; then
				read Imageurl _ < <(getimageurls ${Imageurl} "${_Imagepattern}"|sort -Vr)
			fi
		fi

		if [[ -n "$Imageurl" ]]; then
			if [[ -n "$OnlyGetUrl" ]]; then
				echo -e "image url: $Imageurl"
			else
				echo -e "image url: \e[4m$Imageurl\e[0m"
			fi
		else
			echo "{VM:WARN} not found image from ${Imageurl} by pattern(${_Imagepattern})" >&2
			exit 1
		fi
	fi
fi

if [[ "$InstallType" = location ]]; then
	_MSIZE=2048

	if [[ $Intranet = yes && -z "$Location" ]]; then
		echo "{VM:INFO} getting fastest location of $Distro ..." >&2
		Location=$(distro2location $Distro)
	fi

	if [[ -n "$Location" ]]; then
		if [[ -n "$OnlyGetUrl" ]]; then
			echo -e "location url: $Location"
		else
			echo -e "location url: \e[4m$Location\e[0m"
		fi
	else
		echo "{VM:WARN} can not find distro location. please check if '$Distro' is valid distro" >&2
		exit 1
	fi
fi

[[ -n "$OnlyGetUrl" ]] && { exit; }


if [[ "$InstallType" = pxe ]]; then
	_MSIZE=2048
fi

MSIZE=${MSIZE:-$_MSIZE}
[[ "$MSIZE" = *[Gg] ]] && MSIZE=$((${MSIZE%[Gg]} * 1024))

echo "{VM:INFO} guess/verify os-variant ..."
[[ -z "$VM_OS_VARIANT" ]] && {
	VM_OS_VARIANT=${Distro/-/}
	VM_OS_VARIANT=${VM_OS_VARIANT%%-*}
	VM_OS_VARIANT=${VM_OS_VARIANT,,}
}
osvariants=$(virt-install --os-variant list 2>/dev/null) ||
	osvariants=$(osinfo-query os 2>/dev/null)
[[ -n "$osvariants" ]] && {
	grep -q "^ $VM_OS_VARIANT " <<<"$osvariants" || VM_OS_VARIANT=${VM_OS_VARIANT/.*/-unknown}
	grep -q "^ $VM_OS_VARIANT " <<<"$osvariants" || VM_OS_VARIANT=${VM_OS_VARIANT/[0-9]*/-unknown}
	if grep -q "^ $VM_OS_VARIANT " <<<"$osvariants"; then
		OS_VARIANT_OPT=--os-variant=$VM_OS_VARIANT
	fi
}

# Phase-2: start create VM
# prepare ssh pub key
[[ -f ~/.ssh/id_rsa && -f ~/.ssh/id_rsa.pub ]] || {
	echo -e 'y\n' | ssh-keygen -q -t rsa -f ~/.ssh/id_rsa -N ''
}
[[ -f ~/.ssh/id_ecdsa && -f ~/.ssh/id_ecdsa.pub ]] || {
	echo -e 'y\n' | ssh-keygen -q -t ecdsa -f ~/.ssh/id_ecdsa -N ''
}
# prepare network option
[[ -z "$NETWORK_OPTS" ]] && {
	srcif=$(get_default_if)
	if [[ "$InstallType" = pxe ]]; then
		NETWORK_OPTS="--network=type=direct,source=$srcif,source_mode=$MacvtapMode,model=virtio"
	else
		NETWORK_OPTS="--network=network=default,model=virtio --network=type=direct,source=$srcif,source_mode=$MacvtapMode,model=virtio"
	fi
}

### hostdev option
nic2pcislot() {
	local nic=$1
	local eventf=/sys/class/net/$nic/device/uevent
	if [[ -e $eventf ]]; then
		awk -F= '/PCI_SLOT_NAME/{print "pci_" $2}' $eventf | sed 's/[:.]/_/g'
	fi
}
HOST_DEV_OPTS=()
for dev in "${HOST_DEV_LIST[@]}"; do
	HOST_DEV_OPTS+=("--hostdev=$dev")
done
for nic in "${HOST_NIC_LIST[@]}"; do
	pcislot=$(nic2pcislot $nic)
	if [[ -n "$pcislot" ]]; then
		HOST_DEV_OPTS+=("--hostdev=$pcislot")
	else
		echo -e "{VM:WARN} host nic '$nic' is not a pci device" >&2
	fi
done

### xdisk option
k=0
for disk in "${EXTRA_DISKS[@]}"; do
	read size fstype _ <<<"${disk//,/ }"
	ximage=xdisk$((k++)).qcow2
	format=qcow2
	if [[ -z "$fstype" ]]; then
		qemu-img create -f qcow2 $VMpath/$ximage ${size}G
	else
		ximage=${ximage/qcow2/img}
		format=raw
		sudo bash -c "$(declare -f create_vdisk); create_vdisk $VMpath/$ximage ${size}G $fstype"
	fi
	DISK_OPTS+=" --disk path=$VMpath/$ximage,format=$format,bus=virtio"  #bus=scsi
done

### disk option
for disk in "${DISKS[@]}"; do
	read img arg <<<"${disk/,/ }"
	if [[ ! -f "$img" ]]; then
		echo -e "\n{VM:WARN} '--disk $disk': file '$img' does not exist, ignore it.\n"
		continue
	fi
	cp -f $img $VMpath/.
	DISK_OPTS+=" --disk path=$VMpath/$img,${arg:-bus=ide}"
done

### nvme option
c=0
for devinfo in "${NVME_DEVS[@]}"; do
	for attr in ${devinfo//,/ }; do
		case $attr in
		size=*) fsize=${attr#size=};;
		format=*) format=${attr#format=};;
		esac
	done
	format=${format:-qcow2}
	devfile=nvme$c.$format
	qemu-img create -f $format $VMpath/$devfile ${fsize}G
	{ _user=qemu; id qemu 2>/dev/null || _user=libvirt-qemu; }
	setfacl -mu:qemu:rwx -mg:qemu:rwx $VMpath/$devfile
	chcon system_u:object_r:qemu_var_run_t:s0 $VMpath/$devfile #system_u:object_r:virt_cache_t:s0 also works
	getfacl $VMpath/$devfile
	ls -lZ $VMpath/$devfile
	QEMU_OPTS+=("--qemu-commandline=-drive file=$VMpath/$devfile,format=$format,if=none,id=NVME$c -device nvme,drive=NVME$c,serial=nvme-$c")
	let c++
done

### nvdimm option
CONTROLLER_OPTS=
if [[ "${#NVDIMM_LIST[@]}" -gt 0 ]]; then
	CONTROLLER_OPTS="--controller=type=pci,index=9,model=pcie-root-port --controller=type=pci,index=10,model=pcie-root-port"

	hpmemMax=$((1024*512))   #units Mi
	memSlots=4
	MEM_OPTS="--memory=${MSIZE},hotplugmemorymax=$hpmemMax,hotplugmemoryslots=$memSlots --cpu cell0.cpus=0-$((VCPUS-1)),cell0.memory=$((MSIZE*1024))"

	nvdimmdevs=("${NVDIMM_LIST[@]}")
	for ((i=0; i<${#nvdimmdevs[@]}; i++)); do
		[[ $i -ge $memSlots ]] && break
		nvdimmfile=$VMpath/nvdimm-$i.dev
		read targetSize labelSize _ <<<"${nvdimmdevs[$i]//+/ }"
		targetSize=${targetSize:-511}
		labelSize=${labelSize:-1}
		totalSize=$((targetSize+labelSize))
		truncate -s ${totalSize}M $nvdimmfile
		MEM_OPTS+=" --memdev nvdimm,source_path=$nvdimmfile,target_size=${targetSize},target_node=0,target_label_size=${labelSize}"
	done
fi

### sharedir(virtio) option
if [[ ${#SHARE_DIRS[@]} -gt 0 ]]; then
	INTERACT=no
	MEM_OPTS+=" --memorybacking=access.mode=shared"

	hpmemMax=$((1024*512))   #units Mi
	memSlots=4
	MEM_OPTS+=" --memory=${MSIZE},hotplugmemorymax=$hpmemMax,hotplugmemoryslots=$memSlots --cpu cell0.cpus=0-$((VCPUS-1)),cell0.memory=$((MSIZE*1024))"

	#ref: https://libvirt.org/kbase/virtiofs.html#id3
	#- The host-side virtiofsd daemon, like other vhost-user backed devices,
	#- requires shared memory between the host and the guest.
	virsh allocpages 2M $((MSIZE/2))
	#or add memory_backing_dir = "/dev/shm/" in /etc/libvirt/qemu.conf
fi

MEM_OPTS=${MEM_OPTS:---memory=${MSIZE}}

case ${Distro,,} in
rhel-5*|rhel5*|centos5*|centos-5*)
	EPEL=http://archive.fedoraproject.org/pub/archive/epel/epel-release-latest-5.noarch.rpm;;
rhel-6*|rhel6*|centos6*|centos-6*)
	EPEL=http://dl.fedoraproject.org/pub/epel/epel-release-latest-6.noarch.rpm;;
rhel-7*|rhel7*|centos7*|centos-7*)
	EPEL=http://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm;;
rhel-8*|rhel8*|centos-8*|centos8*|rocky-8*|rocky8*)
	EPEL=http://dl.fedoraproject.org/pub/epel/epel-release-latest-8.noarch.rpm;;
rhel-9*|rhel9*|rocky-9*|rocky9*)
	EPEL=http://dl.fedoraproject.org/pub/epel/epel-release-latest-9.noarch.rpm;;
esac
[[ -n "$EPEL" ]] && PKGS="$EPEL $PKGS"

if [[ "$InstallType" = location ]]; then
	[[ -z "$KSPath" ]] && {
		echo "{VM:INFO} generating kickstart file for $Distro ..."
		ksauto=$VMpath/ks-$VM_OS_VARIANT-$$.cfg
		postscript=$VMpath/postscript.ks
		KSPath=$ksauto
		REPO_OPTS=$(distro2repos $Distro $Location | sed 's/^/--repo /')
		_file=ks-generator.sh
		command -v $_file >/dev/null || {
			_url=$baseUrl/utils/$_file
			mkdir -p ~/bin && curl_download ~/bin/$_file $_url && chmod +x ~/bin/$_file
		}

		cat <<-END >>$postscript
		test -f /etc/yum.repo.d/cdn_os.repo && sed -i 's/enabled = 1/enabled = 0/' /etc/yum.repo.d/cdn_os.repo

		echo "[\$USER@\${HOSTNAME} \${HOME} \$(pwd)] configure hostname ..."
		test -f /etc/hostname && echo ${vmhostname} >/etc/hostname || echo HOSTNAME=${vmhostname} >>/etc/sysconfig/network

		echo "[\$USER@\${HOSTNAME} \${HOME} \$(pwd)] yum install pkgs ${PKGS} ..."
		yum install -y wget ${PKGS} 2>/dev/null

		END
		[[ $Intranet = yes ]] && cat <<-END >>$postscript
		echo "[\$USER@\${HOSTNAME} \${HOME} \$(pwd)] brew install $BPKGS ..."
		wget -O /usr/bin/brewinstall.sh -N -q $bkrClientImprovedUrl/utils/brewinstall.sh --no-check-certificate
		chmod +x /usr/bin/brewinstall.sh
		brewinstall.sh $(for b in $BPKGS; do echo "'$b' "; done) -noreboot

		END

		[[ "$fips" = yes ]] && cat <<-END >>$postscript
		echo "[\$USER@\${HOSTNAME} \${HOME} \$(pwd)] enable fips ..."
		wget -O /usr/bin/enable-fips.sh -N -q $baseUrl/utils/enable-fips.sh --no-check-certificate
		chmod +x /usr/bin/enable-fips.sh
		enable-fips.sh

		END
		[[ "$kdump" = yes ]] && cat <<-END >>$postscript
		echo "[\$USER@\${HOSTNAME} \${HOME} \$(pwd)] kdump-setup ..."
		wget -O /usr/bin/kdump-setup.sh -N -q $baseUrl/utils/kdump-setup.sh --no-check-certificate
		chmod +x /usr/bin/kdump-setup.sh
		kdump-setup.sh
		END
		[[ "$GenerateImage" = yes ]] && {
			cat <<-END >>$postscript
			test -f /etc/yum.repo.d/cdn_os.repo && sed -i 's/enabled = 0/enabled = 1/' /etc/yum.repo.d/cdn_os.repo
			echo "[\$USER@\${HOSTNAME} \${HOME} \$(pwd)] install cloud-init ..."
			yum install -y cloud-init
			test -f /etc/yum.repo.d/cdn_os.repo && sed -i 's/enabled = 1/enabled = 0/' /etc/yum.repo.d/cdn_os.repo
			END
		}
		if [[ ! -f $Location ]]; then
			URL_OPT="-url $Location"
		fi
		if [[ "$NO_SSHKEY" = yes ]]; then
			ks-generator.sh -d $Distro $URL_OPT $REPO_OPTS $_REPO_OPTS --post $postscript >$KSPath
		else
			ks-generator.sh -d $Distro $URL_OPT $REPO_OPTS $_REPO_OPTS --post $postscript --sshkeyf ~/.ssh/id_rsa.pub --sshkeyf ~/.ssh/id_ecdsa.pub >$KSPath
		fi
	}

	echo -e "{VM:INFO} creating VM by using location:\n ->  $Location"
	touch $VMpath/.kiss-vm
	echo $Location >$VMpath/url
	if [[ -f $Location ]]; then
		cp $Location $VMpath/. && Location=$VMpath/${Location##*/}
	fi

	[[ "$GenerateImage" = yes ]] && {
		sed -i '/^reboot$/s//poweroff/' ${KSPath}
		NOREBOOT=--noreboot
	}
	ksfile=${KSPath##*/}
	qemu-img create -f qcow2 $VMpath/${vmname}.qcow2 ${DSIZE}G

	[[ "$DEBUG" = yes ]] && {
		echo "#[debug] kickstart:"
		cat ${KSPath}
	}

	#workaround: see Bug 1707389 #c15
	workaroundExtraArgs="rd.driver.pre=loop"
	run nohup virt-install --connect=qemu:///system --hvm --accelerate $XML "$QEMU_OPTS" "${QEMU_ENV[@]}" \
	  "${HOST_DEV_OPTS[@]}" \
	  "${VIRT_INSTALL_OPTS[@]}" \
	  --name $vmname \
	  --location $Location \
	  $OS_VARIANT_OPT \
	  $MACHINE_OPT \
	  --vcpus ${VCPUS} \
	  $MEM_OPTS \
	  --disk path=$VMpath/${vmname}.qcow2,${BOOT_DISK_ATTRS} \
	  $DISK_OPTS \
	  $NETWORK_OPTS $CONTROLLER_OPTS \
	  --initrd-inject $KSPath \
	  --extra-args="inst.ks=file:/$ksfile console=tty0 console=ttyS0,${baudrate}n8 $workaroundExtraArgs" \
	  --noautoconsole \
	  $VTPM_OPT \
	  --vnc --vnclisten 0.0.0.0 $NOREBOOT &>$VMpath/nohup.log &

	while true; do test -s $VMpath/nohup.log && break; done
	expect -c "spawn tail -f $VMpath/nohup.log
		expect {
			{* to complete the installation process.} { exit }
			{*\r} { exp_continue }
			{</domain>} { exit }
		}
	"

	[[ -n "$XML" ]] && {
		cp $VMpath/nohup.log $VMpath/vm.xml
		virsh domxml-to-native qemu-argv $VMpath/vm.xml | tee $VMpath/qemu-argv
		rm -f $VMpath/*
		exit
	}

	if [[ "$NOAUTO" = yes ]]; then
		expect -c '
			set timeout 10
			spawn virsh console '"$vmname"'
			expect {
				timeout {
					send_user "\n\n{VM:INFO} exiting from console...\n"
					exit 0
				}
				exp_continue
			}
		'
	else
		trap - SIGINT
		for ((i=0; i<31; i++)); do
			#clear -x
			printf '\33[H\33[2J'
			INTERACT=$INTERACT LANG=C expect -c '
				set intc 0
				set timeout -1
				spawn virsh console '"$vmname"'
				trap {
					send_user "You pressed Ctrl+C [incr intc]/8\n"
					if {$intc >= 8} {
						interact
					}
				} SIGINT
				expect {
					"error: Disconnected from qemu:///system due to end of file*" {
						send "\r"
						puts $expect_out(buffer)
						exit 5
					}
					"error: failed to get domain" {
						send "\r"
						puts $expect_out(buffer)
						exit 6
					}
					"error: internal error: character device console0 is not using a PTY" {
						send "\r"
						puts $expect_out(buffer)
						exit 1
					}
					"Unsupported Hardware Detected" {
						send "\r"
						exp_continue
					}
					"Which would you like to install through" {
						# see: [RHEL 6.1] Anaconda requires user interaction in case of kickstart network activation failing
						send "\r"
						interact
					}

					"reboot: Power down" { exit 0 }
					"Power down" { exit 0 }

					"reboot: Restarting system" { send "\r"; exit 1 }
					"Restarting system" { send "\r"; exit 1 }

					"error: The domain is not running" { send "\r"; exit 127 }

					"reboot: System halted" { send_user "\r\rsomething is wrong! cancel installation ..\r\r"; exit 255 }
					"System halted" { send_user "\r\rsomething is wrong! cancel installation ..\r\r"; exit 255 }

					"An unknown error has occurred" { exit 255 }
					"error: Domain not found:" { exit 255 }

					"* login:" { send "root\r" }
				}
				expect "Password:" {
					send "'"$defaultPasswd"'\r"
					send "\r\r\r\r\r\r"
					send "# your are in console, Ctr + ] to exit \r"
					send "\r\r\r\r\r\r"
				}

				if {$env(INTERACT) == "no"} { exit 0 }
				interact
			'
			ReturnCode=$?
			[[ $ReturnCode = 0 || $ReturnCode = 255 ]] && break
			[[ $ReturnCode = 127 ]] && { virsh start $vmname 2>&1 | sed 's/error: //'; continue; }
			sleep 2
		done
		echo -e "\n{VM:INFO} Quit from expect -c 'spawn virsh console $vmname'"

		[[ $ReturnCode = 255 ]] && {
			echo -e "\n{VM:INFO} something is wrong(please check screen log), will clean all tmp files ..."
			RM=yes
			GenerateImage=
		}
	fi

elif [[ "$InstallType" = import ]]; then
	[[ -f $Imageurl ]] && Imageurl=file://$(readlink -f ${Imageurl})
	imagefilename=${Imageurl##*/}
	imagefile=$VMpath/$imagefilename

	echo "{VM:INFO} downloading cloud image file of $Distro to $imagefile ..."
	if [[ $Imageurl != file:///* ]]; then
		if [[ -n "$SAVE_IMAGE" ]]; then
			curl_download_x ${DownloadImagePath}/${imagefilename} $Imageurl
			[[ "$DOWNLOAD_ONLY" = yes ]] && {
				ls -l ${DownloadImagePath}/${imagefilename}
				exit 0
			}
			cp ${DownloadImagePath}/${imagefilename} $imagefile
		else
			curl_download_x $imagefile $Imageurl
		fi
	else
		cp -f ${Imageurl#file://} $imagefile
	fi
	[[ -f ${imagefile} ]] || exit 1

	[[ $imagefile = *.xz ]] && {
		echo "{VM:INFO} decompress $imagefile ..."
		xz -d $imagefile
		rm -f $imagefile
		imagefile=${imagefile%.xz}
		[[ -f ${imagefile} ]] || exit 1
	}

	[[ "$NO_CLOUD_INIT" != yes ]] && {
		echo -e "{VM:INFO} creating cloud-init iso"
		_file=cloud-init-iso-gen.sh
		command -v $_file >/dev/null || {
			_url=$baseUrl/utils/$_file
			mkdir -p ~/bin && curl_download ~/bin/$_file $_url && chmod +x ~/bin/$_file
		}
		cloudinitiso=$VMpath/$vmname-cloud-init.iso
		iso_bus_type=
		[[ "${Distro,,}" = debian* ]] && iso_bus_type=,bus=scsi

		[[ "$fips" = yes ]] && FIPS_OPT=--fips
		[[ "$kdump" = yes ]] && KDUMP_OPT=--kdump
		[[ $Intranet = yes && -n "$Location" ]] && {
			REPO_OPTS=$(distro2repos $Distro $Location | sed -e '/cdn_os:/d' -e 's/^/--repo /')
		}
		[[ "$DEBUG" = yes ]] && DEBUG_OPT=--debug
		if [[ "$NO_SSHKEY" = yes ]]; then
			cloud-init-iso-gen.sh $cloudinitiso -hostname ${vmhostname} -b "$BPKGS" -p "$PKGS" $DEBUG_OPT $REPO_OPTS \
				 $_REPO_OPTS $FIPS_OPT $KDUMP_OPT
		else
			cloud-init-iso-gen.sh $cloudinitiso -hostname ${vmhostname} -b "$BPKGS" -p "$PKGS" $DEBUG_OPT $REPO_OPTS \
				 $_REPO_OPTS $FIPS_OPT $KDUMP_OPT --sshkeyf ~/.ssh/id_rsa.pub --sshkeyf ~/.ssh/id_ecdsa.pub
		fi
		CLOUD_INIT_OPT="--disk $cloudinitiso,device=cdrom$iso_bus_type"
	}

	echo -e "{VM:INFO} creating VM by import $imagefile"
	touch $VMpath/.kiss-vm
	echo $Imageurl >$VMpath/url

	[[ "$dsizeflag" = 1 || "$NOAUTO" != yes ]] && {
		_size=$(qemu-img info ${imagefile}|sed -rn '/^virtual size:.*\(([0-9]+).*$/{s//\1/;p}')
		[[ "$_size" -lt $((DSIZE*1024*1024*1024)) ]] && {
			echo -e "{VM:INFO} resize $imagefile to ${DSIZE}G"
			qemu-img resize ${imagefile} ${DSIZE}G
		}
	}

	run nohup virt-install --connect=qemu:///system --hvm --accelerate $XML "$QEMU_OPTS" "${QEMU_ENV[@]}" \
	  "${HOST_DEV_OPTS[@]}" \
	  "${VIRT_INSTALL_OPTS[@]}" \
	  --name $vmname \
	  $OS_VARIANT_OPT \
	  $MACHINE_OPT \
	  --vcpus ${VCPUS} \
	  $MEM_OPTS \
	  --disk path=${imagefile},${BOOT_DISK_ATTRS} \
	  $DISK_OPTS \
	  $CLOUD_INIT_OPT \
	  $NETWORK_OPTS $CONTROLLER_OPTS \
	  --import \
	  --noautoconsole \
	  $VTPM_OPT \
	  --vnc --vnclisten 0.0.0.0 &>$VMpath/nohup.log &

	while true; do test -f $VMpath/nohup.log && break; done
	expect -c "spawn tail -f $VMpath/nohup.log
		expect {
			{*Domain creation completed.} { exit }
			{*\r} { exp_continue }
			{</domain>} { exit }
		}
	"
	[[ -n "$XML" ]] && {
		cp $VMpath/nohup.log $VMpath/vm.xml
		virsh domxml-to-native qemu-argv $VMpath/vm.xml | tee $VMpath/qemu-argv
		exit
	}

	if [[ "$NOAUTO" = yes ]]; then
		expect -c '
			set timeout 10
			spawn virsh console '"$vmname"'
			expect {
				timeout {
					send_user "\n\n{VM:INFO} exiting from console...\n"
					exit 0
				}
				exp_continue
			}
		'
		if [[ -n "$VNCPUT_AFTER_INSTALL" ]]; then
			vm vnc "$vmname" -put "$VNCPUT_AFTER_INSTALL"
		else
			vm vnc "$vmname" -get
		fi

		echo -e "{VM:INFO} vnc info:"
		vm vncport $vmname
	else
		if grep -i -q freebsd <<<"$Distro"; then
			echo -e "{VM:INFO} waiting login: prompt ..."
                        while ! grep "^login:" < <(vm vnc "$vmname" -get); do sleep 10; done
			vm vnc "$vmname" -putln root
			vm vnc "$vmname" -putln "hostname ${vmname}" \
				-putln "echo 'hostname=\"${vmname}\"' >>/etc/rc.conf" \
				-putln "service syslogd reload" \
				-putln "echo 'sshd_enable=\"YES\"' >>/etc/rc.conf" \
				-putln "printf 'PermitRootLogin yes\\nPasswordAuthentication yes\\n' >>/etc/ssh/sshd_config" \
				-putln "grep '^[^#]' /etc/rc.conf" \
				-putln "grep '^[^#]' /etc/ssh/sshd_config"
			timeout 5 vm vnc "$vmname" -get
			vm vnc "$vmname" -putln "pw useradd foo -G wheel" \
				-putln "passwd foo" -put "" -putln "$defaultPasswd" -put "" -putln "$defaultPasswd" \
				-putln "passwd root" -put "" -putln "$defaultPasswd" -put "" -putln "$defaultPasswd" \
				-putln "/etc/rc.d/sshd start"
			timeout 5 vm vnc "$vmname" -get
			read _vmaddr < <(vmifaddr $vmname)
			expect -c "
				spawn ssh-copy-id -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no root@$_vmaddr
				expect -re .*: {send \"$defaultPasswd\\r\"}
				expect eof
			"
		else
			trap - SIGINT
			for ((i=0; i<31; i++)); do
				INTERACT=$INTERACT SHUTDOWN=$GenerateImage LANG=C expect -c '
					set intc 0
					set timeout -1
					spawn virsh console '"$vmname"'
					trap {
						send_user "You pressed Ctrl+C [incr intc]/8\n"
						if {$intc >= 8} {
							interact
						}
					} SIGINT
					expect {
						"error: failed to get domain" {
							send "\r"
							puts $expect_out(buffer)
							exit 6
						}
						"error: internal error: character device console0 is not using a PTY" {
							send "\r"
							puts $expect_out(buffer)
							exit 1
						}
						"* login:" { send "root\r" }
					}
					expect "Password:" {
						send "'"$defaultPasswd"'\r"
						send "\r\r\r\r\r\r"
						if {$env(SHUTDOWN) == "yes"} {
							send {while ps axf|grep -A1 "/var/lib/cloud/instance/scripts/runcm[d]"; do echo "{VM:INFO}: cloud-init scirpt is still running .."; sleep 10; done; poweroff}
							send "\r\n"
							expect "Restarting system" { exit 0 }
						}

						send {while ps axf|grep -A1 "/var/lib/cloud/instance/scripts/runcm[d]"; do echo "{VM:INFO}: cloud-init scirpt is still running .."; sleep 10; done; echo "~~~~~~~~ no cloud-init or cloud-init done ~~~~~~~~"\d}
						send "\r\n"
						expect {
							"or cloud-init done ~~~~~~~~d" {send "\r\r# Now you can take over the keyboard\r\r"}
							"* login:" {
								send "root\r"
								expect "Password:" {
									send "'"$defaultPasswd"'\r"
									send "\r\r# Now you can take over the keyboard\r\r"
								}
							}
						}
						send "# and your are in console, Ctr + ] to exit \r"
						send "\r\r"
					}

					if {$env(INTERACT) == "no"} { exit 0 }
					interact
				'
				ReturnCode=$?
				[[ $ReturnCode = 0 || $ReturnCode = 255 ]] && break
				[[ $ReturnCode = 127 ]] && { virsh start $vmname 2>&1 | sed 's/error: //'; continue; }
				sleep 2
			done

			echo -e "\n{VM:INFO} Quit from expect -c 'spawn virsh console $vmname'"

			[[ -f "$cloudinitiso" && "$iso_bus_type" != *=usb ]] && {
				echo -e "\n{VM:INFO} eject iso ${cloudinitiso##*/} from $vmname"
				virsh change-media $vmname $cloudinitiso --eject 2>/dev/null
			}
		fi
	fi
elif [[ "$InstallType" = pxe ]]; then
	imagefile=$VMpath/${vmname}.qcow2
	diskOpt=path=${imagefile},bus=virtio,size=${DSIZE}
	[[ "$DISKLESS" = yes ]] && diskOpt=none

	run virt-install --connect=qemu:///system --hvm --accelerate $XML "$QEMU_OPTS" "${QEMU_ENV[@]}" \
	  "${HOST_DEV_OPTS[@]}" \
	  "${VIRT_INSTALL_OPTS[@]}" \
	  --name $vmname \
	  $OS_VARIANT_OPT \
	  $MACHINE_OPT \
	  --vcpus ${VCPUS} \
	  $MEM_OPTS \
	  --pxe \
	  --disk $diskOpt \
	  --noautoconsole \
	  $VTPM_OPT \
	  ${NETWORK_OPTS%,model=virtio} \
	  --vnc --vnclisten 0.0.0.0

	sleep 1
	vm vnc $vmname -get

	if [[ "$NOAUTO" = yes ]]; then
		echo -e "{VM:INFO} waiting boot: prompt ..."
		while ! grep "^boot:" < <(vm vnc "$vmname" -get); do sleep 1; done
		vm vnc $vmname -get
		vm vnc $vmname -putln "menu"
		vm vnc $vmname -put "key:down"
	else
		sleep 10
		vm vnc $vmname -get
	fi

	echo -e "\n{VM:INFO} please connect vnc to continue install:"
	for vncaddr in $(vmvncproc $vmname); do
		echo -e "  $ vncviewer $vncaddr    #from remote"
	done
	exit 0
elif [[ "$InstallType" = cdrom ]]; then
	[[ -f $Isourl ]] && Isourl=file://$(readlink -f ${Isourl})
	isofilename=${Isourl##*/}
	isofile=$VMpath/$isofilename

	echo "{VM:INFO} downloading iso file of $Distro to $isofile ..."
	if [[ $Isourl != file:///* ]]; then
		if [[ -n "$SAVE_IMAGE" ]]; then
			curl_download_x ${DownloadImagePath}/${isofilename} $Isourl
			[[ "$DOWNLOAD_ONLY" = yes ]] && {
				ls -l ${DownloadImagePath}/${isofilename}
				exit 0
			}
			cp ${DownloadImagePath}/${isofilename} $isofile
		else
			curl_download $isofile $Isourl
		fi
	else
		cp -f ${Isourl#file://} $isofile
	fi
	[[ -f ${isofile} ]] || exit 1

	run virt-install --connect=qemu:///system --hvm --accelerate $XML "$QEMU_OPTS" "${QEMU_ENV[@]}" \
	  "${HOST_DEV_OPTS[@]}" \
	  "${VIRT_INSTALL_OPTS[@]}" \
	  --name $vmname \
	  $OS_VARIANT_OPT \
	  $MACHINE_OPT \
	  --vcpus ${VCPUS} \
	  $MEM_OPTS \
	  --cdrom $isofile \
	  $DISK_OPTS \
	  $NETWORK_OPTS $CONTROLLER_OPTS \
	  --noautoconsole \
	  $VTPM_OPT \
	  --vnc --vnclisten 0.0.0.0

	sleep 2
	vm vnc $vmname -get
	vm vnc $vmname -put "key:down" -put "key:up"

	echo -e "\n{VM:INFO} please connect vnc to continue install:"
	for vncaddr in $(vmvncproc $vmname); do
		echo -e "  $ vncviewer $vncaddr    #from remote"
	done
	exit 0
fi

if ! virsh desc $vmname &>/dev/null; then
	echo -e "\n{VM:ERR} virt-install fail"
	rm -rf $VMpath && rmdir {$VMpath%/*} 2>/dev/null
	exit 1
fi

for postrepo in "${POST_REPOS[@]}"; do
	_name=
	_url=
	if [[ "$postrepo" =~ ^[^:]+:(https|http|ftp|file):// ]]; then
		read _name _url _ <<<"${postrepo/:/ }"
	elif [[ "$postrepo" =~ ^(https|http|ftp|file):// ]]; then
		_name=repo-$RADOM
		_url=$postrepo
	fi

	[[ -z "$_name" || -z "$_url" ]] && continue

	repofpath=$VMpath/$_name.repo
	cat <<-REPO >$repofpath
	[$_name]
	name=$_name
	baseurl=$_url
	enabled=1
	gpgcheck=0
	skip_if_unavailable=1
	REPO
	vm cpto $vmname $repofpath /etc/yum.repos.d
	rm -f $repofpath
done

if [[ "$GenerateImage" = yes ]]; then
	mkdir -p $ImagePath/$Distro
	read image < <(virsh dumpxml --domain $vmname | sed -n "/source file=/{s|^.*='||; s|'/>$||; p}")
	imgfilename=${image##*/}
	imgfilename=${imgfilename#${vmprefix}-}
	newimage=$ImagePath/$Distro/${imgfilename}

	echo -e "\n{VM:INFO} force shutdown $vmname ..."
	virsh destroy $vmname 2>/dev/null
	ls -lh ${image}

	if ! true; then
		echo -e "\n{VM:INFO} copy image $image to ${newimage} ..."
		cp ${image} ${newimage}
	else
		echo -e "\n{VM:INFO} virt-sparsify image $image to ${newimage} ..."
		LIBGUESTFS_BACKEND=direct virt-sparsify --check-tmpdir fail ${image} ${newimage} || {
			ls -lh ${image}
			cp ${image} ${newimage}
			LIBGUESTFS_BACKEND=direct virt-sparsify --in-place ${newimage}
		}
		ls -lh ${image}
		ls -lh ${newimage}
	fi

	echo -e "\n{VM:INFO} virt-sysprep ..."
	ls -lh ${newimage}
	LIBGUESTFS_BACKEND=direct virt-sysprep -a ${newimage}
	ls -lh ${newimage}

	echo -e "\n{VM:INFO} xz compress image ..."
	time xz -z -f -T 0 ${XZ:--9} ${newimage}
	ls -lh ${newimage}.xz

	echo -e "\n{VM:INFO} remove temporary VM $vmname ..."
	_vmdelete $vmname
	exit 0
fi

if [[ "$RM" = yes ]]; then
	_vmdelete $vmname
	exit 0
fi

[[ ${#SHARE_DIRS[@]} -gt 0 ]] && {
	vm stop $vmname

	for idx in "${!SHARE_DIRS[@]}"; do
		read srcdir rtarget _ <<< "${SHARE_DIRS[$idx]//:/ }"
		rtarget=${rtarget:-tag$idx}
		target=virtiofs-tag-$rtarget
		mkdir -p $srcdir
		cat >virtiofs.xml <<-EOF
		<filesystem type='mount' accessmode='passthrough'>
			<binary path='/usr/libexec/virtiofsd' xattr='on'/>
			<driver type='virtiofs'/>
			<source dir='$srcdir'/>
			<target dir='$target'/>
		</filesystem>
		EOF
		virsh attach-device $vmname virtiofs.xml --persistent
	done

	vm restart /w $vmname

	for idx in "${!SHARE_DIRS[@]}"; do
		read _ rtarget _ <<< "${SHARE_DIRS[$idx]//:/ }"
		rtarget=${rtarget:-tag$idx}
		target=virtiofs-tag-$rtarget
		mp=/virtiofs/$rtarget
		vm exec -v $vmname -- mkdir -p $mp
		vm exec -v $vmname -- mount -t virtiofs $target $mp
		vm exec -v $vmname -- mount -t virtiofs
	done
}

if [[ ! -f ~/.ssh/config ]]; then
	cat <<-EOF > ~/.ssh/config
	Host 192.168.*.*
	   StrictHostKeyChecking no
	   UserKnownHostsFile=/dev/null
	   LogLevel ERROR

	Host 172.*.*.*
	   StrictHostKeyChecking no
	   UserKnownHostsFile=/dev/null
	   LogLevel ERROR

	Host 10.*.*.*
	   StrictHostKeyChecking no
	   UserKnownHostsFile=/dev/null
	   LogLevel ERROR
	EOF
	chmod 600 ~/.ssh/config
fi

: <<\COMM
echo -e "\n{VM:INFO} attach test disk ext4.qcow2 and xfs.qcow2:"
qemu-img create -f qcow2 $VMpath/ext4.qcow2 10G
qemu-img create -f qcow2 $VMpath/xfs.qcow2 10G
virsh attach-disk $vmname --subdriver qcow2 --persistent $VMpath/ext4.qcow2 vdb #--current --targetbus usb
virsh attach-disk $vmname --subdriver qcow2 --persistent $VMpath/xfs.qcow2 vdc #--current --targetbus usb
#virsh detach-disk $vmname --persistent vdb
#virsh detach-disk $vmname --persistent vdc

echo -e "  $ virsh console $vmname"
echo -e "  $ ssh foo@$vmname  #password: $defaultPasswd"
read addr < <(vmifaddr $vmname)
[[ -n "$addr" ]] && {
	echo -e "  $ ssh foo@$addr  #password: $defaultPasswd"
}
COMM

[[ -n "$DEFAULT_KERNEL" ]] && {
	vm exec -v $vmname -- uname -r
	vm exec -v $vmname -- grubby --default-kernel
	vm exec -v $vmname -- grubby --default-index
	vm exec -v $vmname -- grubby --info=ALL

	pat=${DEFAULT_KERNEL#kernel-}
	defaultIndex=$(vm exec $vmname -- grubby --default-index)
	expectedIndex=$(vm exec $vmname -- grubby --info=ALL | sed 's/^index=/\n/' |
		awk 'BEGIN{RS=""; FS="\n"} '"/$pat/"'{print $1}')

	if [[ "$defaultIndex" != "$expectedIndex" ]]; then
		vm exec -v $vmname -- grubby --set-default-index=$expectedIndex
		REBOOT=yes
	fi
	if ! vm exec $vmname -- uname -r | grep "$pat"; then
		REBOOT=yes
	fi
}
[[ "$REBOOT" = yes ]] && {
	vm exec -v $vmname -- "reboot; exit"
	until port_available ${vmname} 22; do sleep 1; done
}

echo -e "\n{VM:INFO} you can try login $vmname again by using:"
echo -e "  $ vm login $vmname          #from host"
for vncaddr in $(vmvncproc $vmname); do
	if [[ "$vncaddr" = localhost* ]]; then
		echo -e "  $ vncviewer $vncaddr    #from localhost"
	else
		echo -e "  $ vncviewer $vncaddr    #from remote"
	fi
done
exit 0
